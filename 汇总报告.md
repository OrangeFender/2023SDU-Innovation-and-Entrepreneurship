## Project1

### 1.0 生日攻击原理

生日攻击的核心在于用空间换时间，将所有的哈希值都保存下来，每次计算新的哈希值都判断与之前计算过的是否相同。

### 1.1 实现思路

我们首先确定短期找到碰撞的数量级不太可能超过60bit
因此将原像的空间限定在了32bit，使用uint32类型表示一个原像
建立一个原像的数组，将数组索引来表示hash值的前导位。
数组初始化为全0
根据hash结果索引到数组的某个值，如果为0则将值改成原像，如果不是0，则说明找到碰撞。
#### 1.1.0 内存实现
首先在内存中编写程序，发现一般的程序最多申请 $2^{28}$ 长的数组，因此将原像空间限定在unsigned short.

部分代码如下：

```c++
int hash28(char a, char b, char c, char d);
int tem = hash28(hash[0], hash[1], hash[2], hash[3]);
if (arr[tem] != 0)
{
    cout << "找到碰撞，原像为" << i << "和" << arr[tem] << endl;
    cout << "hash值的28位";
    //cout<<tem << endl;
    std::bitset<32> binary5(tem);

    std::cout << binary5 << std::endl;
    clock_t end = clock();

    double endtime = (double)(end - start) / CLOCKS_PER_SEC;

    cout << "寻找hash值28位碰撞花费时间:" << endtime * 1000 << "ms(忽略前四位全0)" << endl;    //ms为单位
    system("pause");
    return 0;
}
else
{
    arr[tem] = i;
}
```

内存版程序实验结果

| 位数     | 28bits   |
|:------:|:--------:|
| **时间** | **53ms** |

发现运行时间实在太短，说明空间严重不足，因此需要将存储转移到硬盘中。

#### 1.1.1 硬盘实现以找到更长的碰撞
尝试找到长度更大的碰撞，因此将数组存储在了硬盘中。申请一个16Gbyte的文件，可以相当于 ` uint32 [1<<32] `的数组
使用`windows.h`的`CreateFileMappingA`方法,可以将文件映射在虚拟的内存空间中，进而正常的索引读取即可。
之后使用上小节的方法即可找出碰撞，碰撞长度为32位。
##### 运行结果
时间为
#### 1.1.1.1
时间依旧太短，因此尝试找到更长的碰撞。
在此使用了新的思路，只需用原方法找到大量的32bit碰撞，其中就可能会含有更长长度的碰撞。
因此在原有代码下增加新的判断即可，代码节选如下:
~~~ C
    printf("try to find more collision\n");
    int best = 0;
    uint32_t i = 1; unsigned long long ind;
    uint32_t best1, best2;
    for (i = 1; i > 0; i++) {
        ind = hash_out4byte(i);
        if (pData[ind] != 0) {
            uint32_t v = pData[ind];
            unsigned char hash1[EVP_MAX_MD_SIZE];
            unsigned char hash2[EVP_MAX_MD_SIZE];
            unsigned int hash_len;
            //printf("The 32bit of the collision is:%x\n", ind);
            //printf("The original image is:%x\nSM3 is:", i); printhash(4, &i);
            //printf("The original image is:%x\nSM3 is:", v); printhash(4, &v);
            EVP_Digest(&v, 4, hash1, &hash_len, EVP_sm3(), NULL);
            EVP_Digest(&i, 4, hash2, &hash_len, EVP_sm3(), NULL);
            int sameBits=countConsecutiveSameBits(hash1, hash2, 32);
            //printf("%d\n", sameBits);
            if (best < sameBits) {
                best = sameBits;
                printf("find %d bits collision\n", best);
                best1 = v;
                best2 = i;
            }
            //if (best > 40)
            //    break;
        }
        pData[ind] = i;
    }
    printf("best collision is %d bits\n", best);
    printf("The original image is:%x\nSM3 is:", best1); printhash(4, &best1);
    printf("The original image is:%x\nSM3 is:", best2); printhash(4, &best2);
~~~
结果见1.2节

#### 1.1.2 关于虚拟内存（内存与硬盘）
做完实验意识到，虚拟内存可以类似地完成上面的工作，多次动态申请数组可以完成上面的工作，但是这两种方式的实际效果应该是差不多的，因为读取方式是完全随机的，内存只是缓存作用。
### 1.2 实现效果
经过层层改进，终于实现了时间和存储的权衡，最终找到了**50bit**的碰撞。
运行结果见文件夹内的截图。
时间消耗约为h
空间占用为16Gbyte
硬盘性能应该为本次实验的关键
硬盘为KIOXIA-EXCERIA G2 SSD PCIe 3.0 x4
运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz

## Project2

### ρ攻击原理

ρ 攻击利用了 SM3 压缩函数中的非线性变换部分，通过构造一组具有特殊结构的输入，使得压缩函数在处理这些输入时，会产生一些特殊的状态。在这些特殊的状态下，压缩函数的输出值会重复出现，从而导致不同的输入最终产生相同的哈希值。

### 实现过程

我们寻找hash函数值的32位的碰撞。

首先，对unsigned int 类型的变量i进行hash的实现方式如下：

```c++
std::string str = std::to_string(x);//转化为字符串
//unsigned int message_len = strlen(str.c_str());

unsigned char hash[EVP_MAX_MD_SIZE];
unsigned int hash_len;

EVP_Digest(str.c_str(), 256, hash, &hash_len, EVP_sm3(), NULL);
```

为得到32位碰撞，我们取四个unsigned char 类型的hash[i]，并将其拼接为一个unsigned int 类型的变量：

```c++
unsigned int join4(unsigned int a, unsigned int b, unsigned int c, unsigned int d)
{
    return ((a << 24) | (b << 16) | (c << 8) | d);
}
```

为接住函数返回的四个hash[i]，我们创建结构体four，并将hash过程写为一个函数，返回一个four类型的结构体：

```c++
struct four {
    unsigned int a;
    unsigned int b;
    unsigned int c;
    unsigned int d;
};


four hash_4(unsigned int x)
{
    four tem;
    std::string str = std::to_string(x);//转化为字符串
    unsigned int message_len = strlen(str.c_str());

    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int hash_len;

    EVP_Digest(str.c_str(), 256, hash, &hash_len, EVP_sm3(), NULL);
    tem.a = (unsigned int)hash[0];
    tem.b = (unsigned int)hash[1];
    tem.c = (unsigned int)hash[2];
    tem.d = (unsigned int)hash[3];
    return tem;
}

```

循环主体如下：

```c++
for (int i = 0; i < ; i++)
    {

        if (tem1.a == tem2.a && tem1.b == tem2.b && tem1.c == tem2.c&&tem1.d==tem2.d)
        {
            cout << "找到32位碰撞" << endl;
            cout << "前32位为0x" << hex << tem1.a << hex << tem1.b << hex << tem1.c << hex << tem1.d << endl;
            cout << "前32位为0x" << hex << tem2.a << hex << tem2.b << hex << tem2.c << hex << tem2.d << endl;
            cout << "循环" << dec << i << "次" << endl;
            clock_t end = clock();
            double endtime = (double)(end - start) / CLOCKS_PER_SEC;
            cout << "寻找hash值32位碰撞花费时间:" << endtime * 1000 << "ms" << endl;    //ms为单位
            //system("pause");
            return 0;
        }
        else
        {
            tem1 = hash_4(result1);
            result1 = join4(tem1.a, tem1.b, tem1.c,tem1.d);


            tem2 = hash_4(result2);
            result2 = join4(tem2.a, tem2.b, tem2.c,tem2.d);
            tem2 = hash_4(result2);
            result2 = join4(tem2.a, tem2.b, tem2.c,tem2.d);

            /*if (i % 100 == 0)
            {
                cout << result1 << endl << result2 << endl;
            }*/
        }

    }
```

### 实现结果

| 位数       | 32bits      |
| -------- | ----------- |
| **循环次数** | **121109次** |
| **时间**   | **678ms**   |

## Project4

### 实现方式

大致思路：主要使用SIMD指令对SM3的消息扩展的阶段进行了加速。

#### 消息扩展阶段

我们首先观察消息扩展阶段的数据依赖情况，发现每个新字需要依赖后面第三个字之前的字，因此我们可以并行的进行消息扩展，每次生成三个新字。
在此使用x86的AVX指令集。

```C

```

### 实现效果

与openssl的实现速度进行对比，计算33554432字节的全零数组的哈希经比较实现结果完全正确。
编译好的程序已经在VS工程目录下的\x64\release文件夹下

#### 时间对比

运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz
||自己的实现|openssl|
|---|---|---|
|时间（毫秒）|||
运行结果截图见文件

## Project5

### 5.1实现方式

使用VS C++编程，哈希函数调用的openssl实现的SHA256.

#### 5.1.1索引方式

看到Merkel Tree的结构，首先想到的是将其用一个满二叉树的索引表示，但是由于叶子节点是从左往右从下往上排列的，因此这样最多会造成一半的存储空间的浪费。

```C++
class Node {
public:
    unsigned char hash[hashlength];
    Node* father;
    Node* lchild;
    Node* rchild;
    transection* son;
    bool isleftchild() {
        return father->lchild == this;
    }
};

```

最终选择了链式存储，由于要从下往上索引，因此加入了父指针。

#### 5.1.2构建方式

采用循环的方式构建二叉树，从最底层开始，如果结点数组的数目是奇数，复制最后一个结点，并将其添加到列表末尾，再创建新结点数组，将原有的结点两两结合成父点。

结点数组是指针数组，便于动态内存管理。

```C++
Node* build(int amount, transection* trans) {
    int oldamlount=amount;
    Node** oldOrder = new Node*[oldamlount];
    for (int i = 0; i < oldamlount; i++)
        oldOrder[i] =new Node(&trans[i]);
    Node** newOrder;
    while (oldamlount > 1) {
        int newamount = (oldamlount + 1) >> 1;
        newOrder = new Node*[oldamlount];
        if (oldamlount % 2) {
            newOrder[newamount-1] = oldOrder[oldamlount -1];//如果结点数组的数目是奇数，复制最后一个结点，并将其添加到列表末尾
        }
        for (int i = 0; i < (newamount- (oldamlount % 2)); i += 1) {
            newOrder[i] = new Node(oldOrder[i*2], oldOrder[i*2 + 1]);//将原有的结点两两结合成父点
        }
        delete[] oldOrder;
        oldOrder = newOrder;
        oldamlount = newamount;
    }
    Node* ret = oldOrder[0];
    delete[] oldOrder;
    return ret;
}
```

#### 5.1.3存在性证明

存在性证明思路比较简单，只需给出哈希节点路线最终得出根节点即可。

#### 5.1.4不存在证明

不存在证明既要证明两个节点存在，又要证明两个节点在逻辑上是相邻的。

##### 相邻证明

要想证明两个叶子节点在逻辑上相邻的，即证明这两个结点之间不会再有任何新的叶子结点即可。
使用如下算法进行判断：

- 从上往下同时遍历两个结点的路径，直到两个路径开始分叉
- 再遍历左节点的路径，如果有向左的路径，立即返回错误
- 再遍历右节点的路径，如果有向右的路径，立即返回错误
- 返回正确

### 5.2实现效果
- 使用链式存储减少了内存浪费
- 构造10w个叶子节点的Merkel Tree用时151.99毫秒。
- 严格完成了存在性证明以及不存在证明（尤其是相邻性证明）。
- 运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz
- 注意了垃圾回收。确保了内存安全。

## Project6

### 6.1实现方式

使用VS C++编程，哈希函数调用的openssl实现的SHA256.

#### 6.1.1认证机构计算并承诺

认证机构根据证明者实际拥有的数量计算对应次数的哈希并对结果签名。

#### 6.1.2证明者计算数据

证明者根据被证明者要求的数据计算对应的哈希。

#### 6.1.3被证明者验证

被证明者用证明者的数据计算对应次数的哈希，并与认证机构的签名结果相比对。

### 6.2实现效果

在本地模拟了网络中的通信过程，并模拟了认证机构计算并签名承诺、证明者根据要求计算并提供数据、被证明者完成证明的过程。
经验证程序结果正确。

## Project7

### 7.1实现方式

按照该网页https://zkproof.org/2021/05/05/hashwires-range-proofs-from-hash-functions/ 的流程编写C++程序。

流程大体分为5步：

#### 7.1.1确定所有的MDP数
首先设定基数，本次设定为16，位数为8，可表示所有的32bit的数。将待证明的数划为多个区间，算法为：从i=1开始，找到连续最低i位基数为最大且小于原数值的最大的数，直到不能找到这样的数为止。
#### 7.1.2计算hashwires
除最高位之外，其他的位均计算最大基数长的hashwire，计算方法同Project6，将其存放在一个8*16的多维数组h中。随后，根据上个算法确定的所有MPD数，逐位索引出h中对应的hash值，每个MPD数索引得到8个哈希值，将这些哈希值一并加盐再哈希即得到每个MPD数的commit。将所有的commit存在一个数组中。
#### 7.1.3构建padded sparse Merkle tree accumulator
首先确定树的高度，树越高，越能隐藏原有信息。在此选用10.

树的构建不同于Project5,因为这棵树是稀疏的，而Project5中的树近乎于满二叉树，因此在此选择由上往下构建的方式，首先随机出所有commit叶子结点的位置(shuffle)，进而根据shuffle由上往下创建节点，再从下往上对结点填充计算内容，进而计算出根节点，得到根commit.
从下往上填充树的过程算法如下：
1. 将结点分为填充叶子结点和commit叶子结点以及非叶子结点。
2. 从一个commit叶子结点的父结点开始。
3. 如果该节点的子节点为填充叶子结点或commit叶子结点或finishied的非叶子节点，则可计算该节点的值，将其标记为finishied,再从该节点的父节点重复该步骤直到根节点。
4. 否则回到2，换下一个commit叶子结点的父结点。
~~~ c++
for (int j = 0; j < NofMDPs; j++) {
        Node* n = leaf[j]->father;
        while (n != NULL) {
            if (n->lchild->finished == false && n->lchild->pad == true) {
                generateRandomArray(n->lchild->hash, Hashlength);
                n->lchild->finished = true;
            }
            if (n->rchild->finished == false && n->rchild->pad == true) {
                generateRandomArray(n->rchild->hash, Hashlength);
                n->rchild->finished = true;
            }
            if (n->lchild->finished == false || n->rchild->finished == false)
                break;
            else
            {
                unsigned char tmp[Hashlength * 2];
                memcpy(tmp, n->lchild->hash, Hashlength);
                memcpy(tmp + Hashlength, n->rchild->hash, Hashlength);
                SHA256(tmp, Hashlength * 2, n->hash);
                n->finished = true;
                n = n->father;
            }
        }
    }
~~~

可以证明这个算法一定能计算出根节点
而且该算法的时间复杂度为树的高度乘以结点数量。
若采用Project5中的构建方法，则复杂度为二的树的高度次幂。
#### 7.1.4给出证明
根据被证明者的要求选出MDP树，并且将计算后的hashwires以及Merkle tree的证明路径发送给被证明者。
#### 7.1.5验证证明
被证明者计算出hashwires，加盐哈希后按路径得到根commit.即可完成证明。
### 7.2实现效果
- 严格按照原文的流程实现了所有的算法，保证了证明过程的零知识性。
- 确保的算法的时间复杂度较小，（尤其是构建Merkel Tree的算法）保证了运行效率。
- 在C++程序编写时特别注意了内存安全。
- 多次运行验证了算法的正确性。
#### 时间测试
完整流程运行时间为1.7毫秒，包括承诺者的承诺生成过程但不包括承诺者的数字签名过程以及网络通信过程。
运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz

## Project10

此project的内容：有关“从签名推出公钥”这一技术在以太坊中的应用的调研报告。具体内容请见文件report.md。

## Project11

### RFC6962

当生成ECDSA签名时，需要保证 $k$ 是保密且唯一的。 $k$ 值重复（弱伪随机）可能导致私钥泄露。

因此在本次实验中令k=hash(M||dA)，其中dA为私钥，hash函数为 sm3算法。

### SM2签名算法

#### 签名算法生成

待签名算法为M，为得到签名（r,s）

1. $\overline{M}=Z_A||M$

2. 计算 $e=H_v(\overline{M})$ ，将 $e$ 转换为整数
3. 随机生成 $k$ ， $k\in[1,n-1]$ 
4. 计算椭圆曲线点 $（x_1,y_1）=[k]G$ ，将 $x_1$ 转换为整数
5. 计算 $r=(e+x_1) mod n$ ,若 $r=0$ 或 $r+k=n$ ，则返回3
6. 计算 $s=((1+d_A)^{-1}\cdot(k-r\cdot d_A))mod n$ ,若 $s=0$ ，则返回3
7. 将 $r、s$ 转换为字节串，签名为 $（r,s）$

#### 签名验证算法

收到消息 $M'$ 及其数字签名 $（r',s'）$ ，验证

1. 检验 $r'\in [1,n-1]$
2. 检验 $s'\in [1,n-1]$
3. 置 $\overline{M'}=Z_A||M'$
4. 计算 $e'=H_v(\overline{M'})$ ，将 $e'$ 转换为整数
5. 将 $r',s'$ 转换为整数，计算 $t=(r'+s')mod n$ ，若 $t=0$ ，则验证不通过
6. 计算椭圆曲线点 $（x'_1,y'_1）=[s']G+[t]P_A$
7. 将 $x1'$ 转换为整数，计算 $R=(e'+x'_1)mod n$ ，检验 $R=r'$ 是否成立

#### 参数选取

$p=0x8542D69E 4C044F18 E8B92435 BF6FF7DE 45728391 5C45517D 722EDB8B 08F1DFC3$

$a=0x787968B4 FA32C3FD 2417842E 73BBFEFF 2F3C848B 6831D7E0 EC65228B 3937E498  $

$b=0x63E4C6D3 B23B0C84 9CF84241 484BFE48 F61D59A5 B16BA06E 6E12D1DA 27C5249A  $

$Gx=0x421DEBD6 1B62EAB6 746434EB C3CC315E 32220B3B ADD50BDC 4C4E6C14 7FEDD43D  $

$Gy=0x0680512B CBB42C07 D47349D2 153B70C4 E5D7FDFC BFA36EA1 A85841B9 E46E09A2 $

$n=0x8542D69E 4C044F18 E8B92435 BF6FF7DD 29772063 0485628D 5AE74EE7 C32E79B7 $

$message='hello'$

$ID_A=0x414C494345313233405941484F4F2E434F4D$

#### 实验结果

![image-20230719171922513](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230719171922513.png)


## Project12

### 项目介绍

ECDMA、Schnorr、SM2-sig存在共同的陷阱，主要陷阱如下：

* Leaking  $k$ leads to leaking of $d$

* Reusing $k$ leads to leaking of $d$

* Two users, using $k$ leads to leaking of $d$, that is they can deduce each other’s $d$

* Malleability, e.g. $(r,s)$ and $(r,-s)$ are both valid signatures, lead to blockchain network split

* Same $d$ and $k$ with ECDSA, leads to leaking of $d$

* Ambiguity of DER encode could lead to blockchain network split

* One can forge signature if the verification does not check $m$

本项目以ECDSA为例，实现了前五个陷阱攻击。

### 结果展示

![image-20230723160825408](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230723160825408.png)

## Project13

### ECMH简介

Elliptic curve MultiSet Hash (ECMH)是一种基于椭圆曲线的多集哈希算法，用于将多个元素映射到一个椭圆曲线上，并将曲线上的点作为哈希值。

ECMH算法的基本思想是，将每个元素编码成一个椭圆曲线上的点，然后将这些点相加得到一个新的点，最终将这个点的坐标作为哈希值。具体来说，ECMH算法的步骤如下：

1. 选择一个椭圆曲线和一个基点，作为哈希算法的参数。
2. 将每个元素编码成一个点，并将所有点相加得到一个新的点。
3. 将新点的X坐标作为哈希值。

ECMH算法的优点是，在保证安全性的前提下，具有较高的哈希速度和较小的哈希值长度。另外，ECMH算法还具有一些其他的特性，如支持动态更新、支持批量哈希等。

ECMH算法已经被应用到了一些密码学应用中，如区块链、数字签名等。但是，由于其相对较新的性质和相对较少的应用经验，目前还没有被广泛使用。

### 实现过程

* 依赖库及参数选取

```python
import numpy as np
import sympy
import hashlib

p=int('0x8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3',16)
a=int('0x787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498',16)
b=int('0x63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A',16) 
```

* 椭圆曲线上加法实现

```python
def calculate_p_q(x1, y1, x2, y2, a, b, p):
    flag = 1

    if x1 == x2 and y1 == y2:
        member = 3 * (x1 ** 2) + a  
        denominator = 2 * y1  

    else:
        member = y2 - y1
        denominator = x2 - x1
        if member * denominator < 0:
            flag = 0
            member = abs(member)
            denominator = abs(denominator)

    gcd_value = get_gcd(member, denominator)
    member = member // gcd_value
    denominator = denominator // gcd_value

    inverse_value = sympy.mod_inverse(denominator, p)
    k = (member * inverse_value)
    if flag == 0:
        k = -k
    k = k % p

    x3 = (k ** 2 - x1 - x2) % p
    y3 = (k * (x1 - x3) - y1) % p
    return [x3, y3]
```

* hash函数选取为sha256

```python
def sha256(data):
    hash_obj = hashlib.sha256()
    hash_obj.update(data)
    return hash_obj.digest()
```

* 多集hash

```python
def multi_hash(set):
    point_0=[0,0]
    for item in set:
        hash_result = sha256(item)
        x=int(hash_result.hex(),16)  
        tem=np.mod(x**2+a*x+b,p)
        y = sympy.ntheory.residue_ntheory.nthroot_mod(tem,2,p)
        while(y==None):
            tem=tem+1
            y = sympy.ntheory.residue_ntheory.nthroot_mod(tem,2,p)
        point=[x,y]
        calculate_p_q(point[0], point[1], point_0[0], point_0[1], a, b, p)
    return point
```

### 实验结果

![image-20230724155045612](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230724155045612.png)


## Project14

### PGP

![image-20230724182230065](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230724182230065.png)



### 实现思路

**算法选取：**

非对称加密算法：sm2

对称加密算法：AES-128-ECB

**加密过程：**

1.发送方和接收方分别生成sm2的公钥和私钥： $(pk_s,sk_s),(pk_r,sk_r)$

2.选取对称加密算法的密钥 $K$ ,用接收方的公钥 $(pk_r)$ 加密，得到 $K_{en}$

3.发送方用 $K$ 加密信息 $m$ ，得到 $m_{en}$

4.发送方用自己的私钥 $(sk_s)$ 签名 $K_{en}$，得到签名 $sign$

5,发送 $K_{en}$， $m_{en}$， $sign$

**解密过程：**

1.对 $K_{en}$ 验签

2.接收方用自己的私钥 $(pk_s)$ 解密 $K_{en}$

3.用 $K$ 解密 $m_{en}$



### 结果展示

![image-20230724183147540](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230724183147540.png)



## Project15

### 实现方式

![image-20230726152246643](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230726152246643.png)

### 实现思路

* 为实现真实网络中的SM2的两方协同签名方案，在此项目中采用python中的socket编程方法进行双方通讯

  **服务端：**

  ```python
  HOST = '127.0.0.1'
  PORT = 50007
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.bind((HOST, PORT)) # 绑定socket
  s.listen(1) # 开始监听客户端连接
  print('Listening on port:',PORT)
  
  conn, addr = s.accept()
  print('Connected by', addr)
  ```

  **客户端：**

  ```python
  # 服务端主机IP地址和端口号
  HOST = '127.0.0.1'
  PORT = 50007
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  try:
      # 连接服务器
      s.connect((HOST, PORT))
  except Exception as e:
      print('Server not found or not open')
      sys.exit()
  ```

* SM2的实现和之前项目类似

  **参数选取：**

  ```python
  p=0x8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3
  
  a=0x787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498
  
  b=0x63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A
  
  xG=0x421DEBD61B62EAB6746434EBC3CC315E32220B3BADD50BDC4C4E6C147FEDD43D
  
  yG=0x0680512BCBB42C07D47349D2153B70C4E5D7FDFCBFA36EA1A85841B9E46E09A2
  
  n=0x8542D69E4C044F18E8B92435BF6FF7DD297720630485628D5AE74EE7C32E79B7
  
  mess1="hello"
  
  IDA=0x414C494345313233405941484F4F2E434F4D
  ```

  **生成P1:**

  ```python
  d1=random.randint(1,n)
  def generate_P1(d1):
      #print(d1)
      d1_inv=mod_inverse(d1,n)
      #print(d1_inv)
      P1=calculate_np(xG, yG, d1_inv, a, b, p)
      return P1
  ```

  **生成Q1,e:**

  ```python
  def generate_e_Q1(ID,mess,P1,k1):
      M = mess.encode()
      ENTL = get_bitsize(ID) * 8
      data = ENTL.to_bytes(2, byteorder='big', signed=False) + int_to_bytes(ID) + 	int_to_bytes(a) + int_to_bytes(b) + int_to_bytes(xG) + int_to_bytes(yG) + 		int_to_bytes(P1[0]) + int_to_bytes(P1[1])
      # print(data)
      ZA = sm3(data)
      M_ = ZA + M
      e = bytes_to_int(sm3(M_))
      Q1 = calculate_np(xG, yG, k1, a, b, p)
      return Q1, e
  ```

  **生成r,s2,s3:**

  ```python
  def generate_r_s2_s3(Q1,e,d2):
      k2 = random.randint(1, n)
      Q2 = calculate_np(xG, yG, k2, a, b, p)
      k3 = random.randint(1, n)
      tem = calculate_np(Q1[0], Q1[1], k3, a, b, p)
      res = calculate_p_q(tem[0], tem[1], Q2[0], Q2[1], a, b, p)
      r = (res[0] + e) % n
      s2 = (d2*k3) % n
      s3 = (d2*(r+k2)) % n
      return r, s2, s3
  ```

### 结果展示

![image-20230726153326850](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230726153326850.png)

![image-20230726153330319](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230726153330319.png)
