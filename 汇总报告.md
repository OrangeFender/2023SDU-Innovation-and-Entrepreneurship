## Project1

### 生日攻击原理

假设有一个函数f，它的输出范围是[0,2^n]，那么我们的攻击就是找到两个不同的x，y，让f(x)=f(y)。这时候，我们可以称x和y发生了碰撞。根据概率论的公式，我们想要达到50%的几率，那么需要尝试的次数是2^(n/2)。 

### 实现思路

我们寻找hash函数值的28位的碰撞。首先创建一个大小为2^(28)的数组：

```c++
unsigned short arr[ 2 << 28];

```

将其全都初始化为0。

然后对unsigned int 类型的变量i进行hash。实现方式如下：

```c++
std::string str = std::to_string(i);//转化为字符串
unsigned int message_len = strlen(str.c_str());
unsigned char hash[EVP_MAX_MD_SIZE];
unsigned int hash_len;
EVP_Digest(str.c_str(), message_len, hash, &hash_len, EVP_sm3(), NULL);
```

hash值结果存于hash[]中。

unsigned char 类型大小为8位，为得到28位，我们取hash[0],hash[1],hash[2],hash[3],将其合并为一个32位usigned int类型的数，并和28位1进行与运算，得到28位的hash值。实现方式如下：

```c++
int hash28(char a, char b, char c, char d)
{
    std::bitset<8> binary0(a);
    //std::cout << binary0 << std::endl;
    std::bitset<8> binary1(b);
    //std::cout << binary1 << std::endl;
    std::bitset<8> binary2(c);
    //std::cout << binary2 << std::endl;
    std::bitset<8> binary3(d);
    //std::cout << binary3 << std::endl;

    unsigned int num0 = static_cast<unsigned int>(binary0.to_ulong());
    unsigned int num1 = static_cast<unsigned int>(binary1.to_ulong());
    unsigned int num2 = static_cast<unsigned int>(binary2.to_ulong());
    unsigned int num3 = static_cast<unsigned int>(binary3.to_ulong());

    int tem1 = (num0 << 24) | (num1 << 16) | (num2 << 8) | num3;

    int mask = (1 << 28) - 1;  // 28 位全为 1 的数
    int tem2 = tem1 & mask;
    return tem2;
}
```

我们采取空间换取时间的方式，每对一个i进行hash，得到28位值x，就令arr[x]=i。这样我们每得到一个值，只需要检测hash[x]是否等于0即可。如果不等于0，那么得到碰撞，两个原像分别为i和arr[x]。如果等于0，就令arr[x]=i。实现过程如下：

```c++
int tem = hash28(hash[0], hash[1], hash[2], hash[3]);
if (arr[tem] != 0)
{
    cout << "找到碰撞，原像为" << i << "和" << arr[tem] << endl;
    cout << "hash值的28位";
    //cout<<tem << endl;
    std::bitset<32> binary5(tem);

    std::cout << binary5 << std::endl;
    clock_t end = clock();

    double endtime = (double)(end - start) / CLOCKS_PER_SEC;

    cout << "寻找hash值28位碰撞花费时间:" << endtime * 1000 << "ms(忽略前四位全0)" << endl;    //ms为单位
    system("pause");
    return 0;
}
else
{
    arr[tem] = i;
}
```

### 实验结果

| 位数     | 28bits   |
|:------:|:--------:|
| **时间** | **53ms** |



## Project2

### ρ攻击原理

ρ 攻击利用了 SM3 压缩函数中的非线性变换部分，通过构造一组具有特殊结构的输入，使得压缩函数在处理这些输入时，会产生一些特殊的状态。在这些特殊的状态下，压缩函数的输出值会重复出现，从而导致不同的输入最终产生相同的哈希值。

### 实现过程

我们寻找hash函数值的32位的碰撞。

首先，对unsigned int 类型的变量i进行hash的实现方式如下：

```c++
std::string str = std::to_string(x);//转化为字符串
//unsigned int message_len = strlen(str.c_str());

unsigned char hash[EVP_MAX_MD_SIZE];
unsigned int hash_len;

EVP_Digest(str.c_str(), 256, hash, &hash_len, EVP_sm3(), NULL);
```

为得到32位碰撞，我们取四个unsigned char 类型的hash[i]，并将其拼接为一个unsigned int 类型的变量：

```c++
unsigned int join4(unsigned int a, unsigned int b, unsigned int c, unsigned int d)
{
    return ((a << 24) | (b << 16) | (c << 8) | d);
}
```

为接住函数返回的四个hash[i]，我们创建结构体four，并将hash过程写为一个函数，返回一个four类型的结构体：

```c++
struct four {
    unsigned int a;
    unsigned int b;
    unsigned int c;
    unsigned int d;
};


four hash_4(unsigned int x)
{
    four tem;
    std::string str = std::to_string(x);//转化为字符串
    unsigned int message_len = strlen(str.c_str());

    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int hash_len;

    EVP_Digest(str.c_str(), 256, hash, &hash_len, EVP_sm3(), NULL);
    tem.a = (unsigned int)hash[0];
    tem.b = (unsigned int)hash[1];
    tem.c = (unsigned int)hash[2];
    tem.d = (unsigned int)hash[3];
    return tem;
}

```

循环主体如下：

```c++
for (int i = 0; i < ; i++)
    {

        if (tem1.a == tem2.a && tem1.b == tem2.b && tem1.c == tem2.c&&tem1.d==tem2.d)
        {
            cout << "找到32位碰撞" << endl;
            cout << "前32位为0x" << hex << tem1.a << hex << tem1.b << hex << tem1.c << hex << tem1.d << endl;
            cout << "前32位为0x" << hex << tem2.a << hex << tem2.b << hex << tem2.c << hex << tem2.d << endl;
            cout << "循环" << dec << i << "次" << endl;
            clock_t end = clock();
            double endtime = (double)(end - start) / CLOCKS_PER_SEC;
            cout << "寻找hash值32位碰撞花费时间:" << endtime * 1000 << "ms" << endl;    //ms为单位
            //system("pause");
            return 0;
        }
        else
        {
            tem1 = hash_4(result1);
            result1 = join4(tem1.a, tem1.b, tem1.c,tem1.d);


            tem2 = hash_4(result2);
            result2 = join4(tem2.a, tem2.b, tem2.c,tem2.d);
            tem2 = hash_4(result2);
            result2 = join4(tem2.a, tem2.b, tem2.c,tem2.d);

            /*if (i % 100 == 0)
            {
                cout << result1 << endl << result2 << endl;
            }*/
        }

    }
```

### 实现结果

| 位数       | 32bits      |
| -------- | ----------- |
| **循环次数** | **121109次** |
| **时间**   | **678ms**   |

## Project4

### 实现方式

大致思路：主要使用SIMD指令对SM3的消息扩展的阶段进行了加速。

#### 消息扩展阶段

我们首先观察消息扩展阶段的数据依赖情况，发现每个新字需要依赖后面第三个字之前的字，因此我们可以并行的进行消息扩展，每次生成三个新字。
在此使用x86的AVX指令集。

```C

```

### 实现效果

与openssl的实现速度进行对比，计算33554432字节的全零数组的哈希经比较实现结果完全正确。
编译好的程序已经在VS工程目录下的\x64\release文件夹下

#### 时间对比

运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz
||自己的实现|openssl|
|---|---|---|
|时间（毫秒）|||
运行结果截图见文件

## Project5

### 5.1实现方式

使用VS C++编程，哈希函数调用的openssl实现的SHA256.

#### 5.1.1索引方式

看到Merkel Tree的结构，首先想到的是将其用一个满二叉树的索引表示，但是由于叶子节点是从左往右从下往上排列的，因此这样最多会造成一半的存储空间的浪费。

```C++
class Node {
public:
    unsigned char hash[hashlength];
    Node* father;
    Node* lchild;
    Node* rchild;
    transection* son;
    bool isleftchild() {
        return father->lchild == this;
    }
};

```

最终选择了链式存储，由于要从下往上索引，因此加入了父指针。

#### 5.1.2构建方式

采用循环的方式构建二叉树，从最底层开始，如果结点数组的数目是奇数，复制最后一个结点，并将其添加到列表末尾，再创建新结点数组，将原有的结点两两结合成父点。

结点数组是指针数组，便于动态内存管理。

```C++
Node* build(int amount, transection* trans) {
    int oldamlount=amount;
    Node** oldOrder = new Node*[oldamlount];
    for (int i = 0; i < oldamlount; i++)
        oldOrder[i] =new Node(&trans[i]);
    Node** newOrder;
    while (oldamlount > 1) {
        int newamount = (oldamlount + 1) >> 1;
        newOrder = new Node*[oldamlount];
        if (oldamlount % 2) {
            newOrder[newamount-1] = oldOrder[oldamlount -1];//如果结点数组的数目是奇数，复制最后一个结点，并将其添加到列表末尾
        }
        for (int i = 0; i < (newamount- (oldamlount % 2)); i += 1) {
            newOrder[i] = new Node(oldOrder[i*2], oldOrder[i*2 + 1]);//将原有的结点两两结合成父点
        }
        delete[] oldOrder;
        oldOrder = newOrder;
        oldamlount = newamount;
    }
    Node* ret = oldOrder[0];
    delete[] oldOrder;
    return ret;
}
```

#### 5.1.3存在性证明

存在性证明思路比较简单，只需给出哈希节点路线最终得出根节点即可。

#### 5.1.4不存在证明

不存在证明既要证明两个节点存在，又要证明两个节点在逻辑上是相邻的。

##### 相邻证明

要想证明两个叶子节点在逻辑上相邻的，即证明这两个结点之间不会再有任何新的叶子结点即可。
使用如下算法进行判断：

- 从上往下同时遍历两个结点的路径，直到两个路径开始分叉
- 再遍历左节点的路径，如果有向左的路径，立即返回错误
- 再遍历右节点的路径，如果有向右的路径，立即返回错误
- 返回正确

### 5.2实现效果
- 使用链式存储减少了内存浪费
- 构造10w个叶子节点的Merkel Tree用时151.99毫秒。
- 严格完成了存在性证明以及不存在证明（尤其是相邻性证明）。
- 运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz
- 注意了垃圾回收。确保了内存安全。

## Project6

### 6.1实现方式

使用VS C++编程，哈希函数调用的openssl实现的SHA256.

#### 6.1.1认证机构计算并承诺

认证机构根据证明者实际拥有的数量计算对应次数的哈希并对结果签名。

#### 6.1.2证明者计算数据

证明者根据被证明者要求的数据计算对应的哈希。

#### 6.1.3被证明者验证

被证明者用证明者的数据计算对应次数的哈希，并与认证机构的签名结果相比对。

### 6.2实现效果

在本地模拟了网络中的通信过程，并模拟了认证机构计算并签名承诺、证明者根据要求计算并提供数据、被证明者完成证明的过程。
经验证程序结果正确。

## Project7

### 7.1实现方式

按照该网页https://zkproof.org/2021/05/05/hashwires-range-proofs-from-hash-functions/ 的流程编写C++程序。

流程大体分为5步：

#### 7.1.1确定所有的MDP数
首先设定基数，本次设定为16，位数为8，可表示所有的32bit的数。将待证明的数划为多个区间，算法为：从i=1开始，找到连续最低i位基数为最大且小于原数值的最大的数，直到不能找到这样的数为止。
#### 7.1.2计算hashwires
除最高位之外，其他的位均计算最大基数长的hashwire，计算方法同Project6，将其存放在一个8*16的多维数组h中。随后，根据上个算法确定的所有MPD数，逐位索引出h中对应的hash值，每个MPD数索引得到8个哈希值，将这些哈希值一并加盐再哈希即得到每个MPD数的commit。将所有的commit存在一个数组中。
#### 7.1.3构建padded sparse Merkle tree accumulator
首先确定树的高度，树越高，越能隐藏原有信息。在此选用10.

树的构建不同于Project5,因为这棵树是稀疏的，而Project5中的树近乎于满二叉树，因此在此选择由上往下构建的方式，首先随机出所有commit叶子结点的位置(shuffle)，进而根据shuffle由上往下创建节点，再从下往上对结点填充计算内容，进而计算出根节点，得到根commit.
从下往上填充树的过程算法如下：
1. 将结点分为填充叶子结点和commit叶子结点以及非叶子结点。
2. 从一个commit叶子结点的父结点开始。
3. 如果该节点的子节点为填充叶子结点或commit叶子结点或finishied的非叶子节点，则可计算该节点的值，将其标记为finishied,再从该节点的父节点重复该步骤直到根节点。
4. 否则回到2，换下一个commit叶子结点的父结点。
~~~ c++
for (int j = 0; j < NofMDPs; j++) {
        Node* n = leaf[j]->father;
        while (n != NULL) {
            if (n->lchild->finished == false && n->lchild->pad == true) {
                generateRandomArray(n->lchild->hash, Hashlength);
                n->lchild->finished = true;
            }
            if (n->rchild->finished == false && n->rchild->pad == true) {
                generateRandomArray(n->rchild->hash, Hashlength);
                n->rchild->finished = true;
            }
            if (n->lchild->finished == false || n->rchild->finished == false)
                break;
            else
            {
                unsigned char tmp[Hashlength * 2];
                memcpy(tmp, n->lchild->hash, Hashlength);
                memcpy(tmp + Hashlength, n->rchild->hash, Hashlength);
                SHA256(tmp, Hashlength * 2, n->hash);
                n->finished = true;
                n = n->father;
            }
        }
    }
~~~

可以证明这个算法一定能计算出根节点
而且该算法的时间复杂度为树的高度乘以结点数量。
若采用Project5中的构建方法，则复杂度为二的树的高度次幂。
#### 7.1.4给出证明
根据被证明者的要求选出MDP树，并且将计算后的hashwires以及Merkle tree的证明路径发送给被证明者。
#### 7.1.5验证证明
被证明者计算出hashwires，加盐哈希后按路径得到根commit.即可完成证明。
### 7.2实现效果
- 严格按照原文的流程实现了所有的算法，保证了证明过程的零知识性。
- 确保的算法的时间复杂度较小，（尤其是构建Merkel Tree的算法）保证了运行效率。
- 在C++程序编写时特别注意了内存安全。
- 多次运行验证了算法的正确性。
#### 时间测试
完整流程运行时间为1.7毫秒，包括承诺者的承诺生成过程但不包括承诺者的数字签名过程以及网络通信过程。
运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz

## Project10

此project的内容：有关“从签名推出公钥”这一技术在以太坊中的应用的调研报告。具体内容请见文件report.md。

## Project11

### RFC6962

当生成ECDSA签名时，需要保证 $k$ 是保密且唯一的。 $k$ 值重复（弱伪随机）可能导致私钥泄露。

因此在本次实验中令k=hash(M||dA)，其中dA为私钥，hash函数为 sm3算法。

### SM2签名算法

#### 签名算法生成

待签名算法为M，为得到签名（r,s）

1. $\overline{M}=Z_A||M$

2. 计算 $e=H_v(\overline{M})$ ，将 $e$ 转换为整数
3. 随机生成 $k$ ， $k\in[1,n-1]$ 
4. 计算椭圆曲线点 $（x_1,y_1）=[k]G$ ，将 $x_1$ 转换为整数
5. 计算 $r=(e+x_1) mod n$ ,若 $r=0$ 或 $r+k=n$ ，则返回3
6. 计算 $s=((1+d_A)^{-1}\cdot(k-r\cdot d_A))mod n$ ,若 $s=0$ ，则返回3
7. 将 $r、s$ 转换为字节串，签名为 $（r,s）$

#### 签名验证算法

收到消息 $M'$ 及其数字签名 $（r',s'）$ ，验证

1. 检验 $r'\in [1,n-1]$
2. 检验 $s'\in [1,n-1]$
3. 置 $\overline{M'}=Z_A||M'$
4. 计算 $e'=H_v(\overline{M'})$ ，将 $e'$ 转换为整数
5. 将 $r',s'$ 转换为整数，计算 $t=(r'+s')mod n$ ，若 $t=0$ ，则验证不通过
6. 计算椭圆曲线点 $（x'_1,y'_1）=[s']G+[t]P_A$
7. 将 $x1'$ 转换为整数，计算 $R=(e'+x'_1)mod n$ ，检验 $R=r'$ 是否成立

#### 参数选取

$p=0x8542D69E 4C044F18 E8B92435 BF6FF7DE 45728391 5C45517D 722EDB8B 08F1DFC3$

$a=0x787968B4 FA32C3FD 2417842E 73BBFEFF 2F3C848B 6831D7E0 EC65228B 3937E498  $

$b=0x63E4C6D3 B23B0C84 9CF84241 484BFE48 F61D59A5 B16BA06E 6E12D1DA 27C5249A  $

$Gx=0x421DEBD6 1B62EAB6 746434EB C3CC315E 32220B3B ADD50BDC 4C4E6C14 7FEDD43D  $

$Gy=0x0680512B CBB42C07 D47349D2 153B70C4 E5D7FDFC BFA36EA1 A85841B9 E46E09A2 $

$n=0x8542D69E 4C044F18 E8B92435 BF6FF7DD 29772063 0485628D 5AE74EE7 C32E79B7 $

$message='hello'$

$ID_A=0x414C494345313233405941484F4F2E434F4D$

#### 实验结果

![image-20230719171922513](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230719171922513.png)


## Project12

### 项目介绍

ECDMA、Schnorr、SM2-sig存在共同的陷阱，主要陷阱如下：

* Leaking  $k$ leads to leaking of $d$

* Reusing $k$ leads to leaking of $d$

* Two users, using $k$ leads to leaking of $d$, that is they can deduce each other’s $d$

* Malleability, e.g. $(r,s)$ and $(r,-s)$ are both valid signatures, lead to blockchain network split

* Same $d$ and $k$ with ECDSA, leads to leaking of $d$

* Ambiguity of DER encode could lead to blockchain network split

* One can forge signature if the verification does not check $m$

本项目以ECDSA为例，实现了前五个陷阱攻击。

### 结果展示

![image-20230723160825408](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230723160825408.png)

## Project13

### ECMH简介

Elliptic curve MultiSet Hash (ECMH)是一种基于椭圆曲线的多集哈希算法，用于将多个元素映射到一个椭圆曲线上，并将曲线上的点作为哈希值。

ECMH算法的基本思想是，将每个元素编码成一个椭圆曲线上的点，然后将这些点相加得到一个新的点，最终将这个点的坐标作为哈希值。具体来说，ECMH算法的步骤如下：

1. 选择一个椭圆曲线和一个基点，作为哈希算法的参数。
2. 将每个元素编码成一个点，并将所有点相加得到一个新的点。
3. 将新点的X坐标作为哈希值。

ECMH算法的优点是，在保证安全性的前提下，具有较高的哈希速度和较小的哈希值长度。另外，ECMH算法还具有一些其他的特性，如支持动态更新、支持批量哈希等。

ECMH算法已经被应用到了一些密码学应用中，如区块链、数字签名等。但是，由于其相对较新的性质和相对较少的应用经验，目前还没有被广泛使用。

### 实现过程

* 依赖库及参数选取

```python
import numpy as np
import sympy
import hashlib

p=int('0x8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3',16)
a=int('0x787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498',16)
b=int('0x63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A',16) 
```

* 椭圆曲线上加法实现

```python
def calculate_p_q(x1, y1, x2, y2, a, b, p):
    flag = 1

    if x1 == x2 and y1 == y2:
        member = 3 * (x1 ** 2) + a  
        denominator = 2 * y1  

    else:
        member = y2 - y1
        denominator = x2 - x1
        if member * denominator < 0:
            flag = 0
            member = abs(member)
            denominator = abs(denominator)

    gcd_value = get_gcd(member, denominator)
    member = member // gcd_value
    denominator = denominator // gcd_value

    inverse_value = sympy.mod_inverse(denominator, p)
    k = (member * inverse_value)
    if flag == 0:
        k = -k
    k = k % p

    x3 = (k ** 2 - x1 - x2) % p
    y3 = (k * (x1 - x3) - y1) % p
    return [x3, y3]
```

* hash函数选取为sha256

```python
def sha256(data):
    hash_obj = hashlib.sha256()
    hash_obj.update(data)
    return hash_obj.digest()
```

* 多集hash

```python
def multi_hash(set):
    point_0=[0,0]
    for item in set:
        hash_result = sha256(item)
        x=int(hash_result.hex(),16)  
        tem=np.mod(x**2+a*x+b,p)
        y = sympy.ntheory.residue_ntheory.nthroot_mod(tem,2,p)
        while(y==None):
            tem=tem+1
            y = sympy.ntheory.residue_ntheory.nthroot_mod(tem,2,p)
        point=[x,y]
        calculate_p_q(point[0], point[1], point_0[0], point_0[1], a, b, p)
    return point
```

### 实验结果

![image-20230724155045612](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230724155045612.png)





