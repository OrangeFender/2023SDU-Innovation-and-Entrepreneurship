## Project1

### 生日攻击原理

假设有一个函数f，它的输出范围是[0,2^n]，那么我们的攻击就是找到两个不同的x，y，让f(x)=f(y)。这时候，我们可以称x和y发生了碰撞。根据概率论的公式，我们想要达到50%的几率，那么需要尝试的次数是2^(n/2)。 

### 实现思路

我们寻找hash函数值的28位的碰撞。首先创建一个大小为2^(28)的数组：

```c++
unsigned short arr[ 2 << 28];

```

将其全都初始化为0。

然后对unsigned int 类型的变量i进行hash。实现方式如下：

```c++
std::string str = std::to_string(i);//转化为字符串
unsigned int message_len = strlen(str.c_str());
unsigned char hash[EVP_MAX_MD_SIZE];
unsigned int hash_len;
EVP_Digest(str.c_str(), message_len, hash, &hash_len, EVP_sm3(), NULL);
```

hash值结果存于hash[]中。

unsigned char 类型大小为8位，为得到28位，我们取hash[0],hash[1],hash[2],hash[3],将其合并为一个32位usigned int类型的数，并和28位1进行与运算，得到28位的hash值。实现方式如下：

```c++
int hash28(char a, char b, char c, char d)
{
    std::bitset<8> binary0(a);
    //std::cout << binary0 << std::endl;
    std::bitset<8> binary1(b);
    //std::cout << binary1 << std::endl;
    std::bitset<8> binary2(c);
    //std::cout << binary2 << std::endl;
    std::bitset<8> binary3(d);
    //std::cout << binary3 << std::endl;

    unsigned int num0 = static_cast<unsigned int>(binary0.to_ulong());
    unsigned int num1 = static_cast<unsigned int>(binary1.to_ulong());
    unsigned int num2 = static_cast<unsigned int>(binary2.to_ulong());
    unsigned int num3 = static_cast<unsigned int>(binary3.to_ulong());

    int tem1 = (num0 << 24) | (num1 << 16) | (num2 << 8) | num3;

    int mask = (1 << 28) - 1;  // 28 位全为 1 的数
    int tem2 = tem1 & mask;
    return tem2;
}
```

我们采取空间换取时间的方式，每对一个i进行hash，得到28位值x，就令arr[x]=i。这样我们每得到一个值，只需要检测hash[x]是否等于0即可。如果不等于0，那么得到碰撞，两个原像分别为i和arr[x]。如果等于0，就令arr[x]=i。实现过程如下：

```c++
int tem = hash28(hash[0], hash[1], hash[2], hash[3]);
if (arr[tem] != 0)
{
    cout << "找到碰撞，原像为" << i << "和" << arr[tem] << endl;
    cout << "hash值的28位";
    //cout<<tem << endl;
    std::bitset<32> binary5(tem);

    std::cout << binary5 << std::endl;
    clock_t end = clock();

    double endtime = (double)(end - start) / CLOCKS_PER_SEC;

    cout << "寻找hash值28位碰撞花费时间:" << endtime * 1000 << "ms(忽略前四位全0)" << endl;    //ms为单位
    system("pause");
    return 0;
}
else
{
    arr[tem] = i;
}
```

### 实验结果

| 位数     | 28bits   |
|:------:|:--------:|
| **时间** | **53ms** |



## Project2

### ρ攻击原理

ρ 攻击利用了 SM3 压缩函数中的非线性变换部分，通过构造一组具有特殊结构的输入，使得压缩函数在处理这些输入时，会产生一些特殊的状态。在这些特殊的状态下，压缩函数的输出值会重复出现，从而导致不同的输入最终产生相同的哈希值。

### 实现过程

我们寻找hash函数值的32位的碰撞。

首先，对unsigned int 类型的变量i进行hash的实现方式如下：

```c++
std::string str = std::to_string(x);//转化为字符串
//unsigned int message_len = strlen(str.c_str());

unsigned char hash[EVP_MAX_MD_SIZE];
unsigned int hash_len;

EVP_Digest(str.c_str(), 256, hash, &hash_len, EVP_sm3(), NULL);
```

为得到32位碰撞，我们取四个unsigned char 类型的hash[i]，并将其拼接为一个unsigned int 类型的变量：

```c++
unsigned int join4(unsigned int a, unsigned int b, unsigned int c, unsigned int d)
{
    return ((a << 24) | (b << 16) | (c << 8) | d);
}
```

为接住函数返回的四个hash[i]，我们创建结构体four，并将hash过程写为一个函数，返回一个four类型的结构体：

```c++
struct four {
    unsigned int a;
    unsigned int b;
    unsigned int c;
    unsigned int d;
};


four hash_4(unsigned int x)
{
    four tem;
    std::string str = std::to_string(x);//转化为字符串
    unsigned int message_len = strlen(str.c_str());

    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int hash_len;

    EVP_Digest(str.c_str(), 256, hash, &hash_len, EVP_sm3(), NULL);
    tem.a = (unsigned int)hash[0];
    tem.b = (unsigned int)hash[1];
    tem.c = (unsigned int)hash[2];
    tem.d = (unsigned int)hash[3];
    return tem;
}

```

循环主体如下：

```c++
for (int i = 0; i < ; i++)
    {

        if (tem1.a == tem2.a && tem1.b == tem2.b && tem1.c == tem2.c&&tem1.d==tem2.d)
        {
            cout << "找到32位碰撞" << endl;
            cout << "前32位为0x" << hex << tem1.a << hex << tem1.b << hex << tem1.c << hex << tem1.d << endl;
            cout << "前32位为0x" << hex << tem2.a << hex << tem2.b << hex << tem2.c << hex << tem2.d << endl;
            cout << "循环" << dec << i << "次" << endl;
            clock_t end = clock();
            double endtime = (double)(end - start) / CLOCKS_PER_SEC;
            cout << "寻找hash值32位碰撞花费时间:" << endtime * 1000 << "ms" << endl;    //ms为单位
            //system("pause");
            return 0;
        }
        else
        {
            tem1 = hash_4(result1);
            result1 = join4(tem1.a, tem1.b, tem1.c,tem1.d);


            tem2 = hash_4(result2);
            result2 = join4(tem2.a, tem2.b, tem2.c,tem2.d);
            tem2 = hash_4(result2);
            result2 = join4(tem2.a, tem2.b, tem2.c,tem2.d);

            /*if (i % 100 == 0)
            {
                cout << result1 << endl << result2 << endl;
            }*/
        }

    }
```

### 实现结果

| 位数       | 32bits      |
| -------- | ----------- |
| **循环次数** | **121109次** |
| **时间**   | **678ms**   |

## Project4

### 实现方式

大致思路：主要使用SIMD指令对SM3的消息扩展的阶段进行了加速。

#### 消息扩展阶段

我们首先观察消息扩展阶段的数据依赖情况，发现每个新字需要依赖后面第三个字之前的字，因此我们可以并行的进行消息扩展，每次生成三个新字。
在此使用x86的AVX指令集。

```C

```

### 实现效果

与openssl的实现速度进行对比，计算33554432字节的全零数组的哈希经比较实现结果完全正确。
编译好的程序已经在VS工程目录下的\x64\release文件夹下

#### 时间对比

运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz
||自己的实现|openssl|
|---|---|---|
|时间（毫秒）|||
运行结果截图见文件

## Project5

### 5.1实现方式

使用VS C++编程，哈希函数调用的openssl实现的SHA256.

#### 5.1.1索引方式

看到Merkel Tree的结构，首先想到的是将其用一个满二叉树的索引表示，但是由于叶子节点是从左往右从下往上排列的，因此这样最多会造成一半的存储空间的浪费。

```C++
class Node {
public:
    unsigned char hash[hashlength];
    Node* father;
    Node* lchild;
    Node* rchild;
    transection* son;
    bool isleftchild() {
        return father->lchild == this;
    }
};

```

最终选择了链式存储，由于要从下往上索引，因此加入了父指针。

#### 5.1.2构建方式

采用循环的方式构建二叉树，从最底层开始，如果结点数组的数目是奇数，复制最后一个结点，并将其添加到列表末尾，再创建新结点数组，将原有的结点两两结合成父点。

结点数组是指针数组，便于动态内存管理。

```C++
Node* build(int amount, transection* trans) {
    int oldamlount=amount;
    Node** oldOrder = new Node*[oldamlount];
    for (int i = 0; i < oldamlount; i++)
        oldOrder[i] =new Node(&trans[i]);
    Node** newOrder;
    while (oldamlount > 1) {
        int newamount = (oldamlount + 1) >> 1;
        newOrder = new Node*[oldamlount];
        if (oldamlount % 2) {
            newOrder[newamount-1] = oldOrder[oldamlount -1];//如果结点数组的数目是奇数，复制最后一个结点，并将其添加到列表末尾
        }
        for (int i = 0; i < (newamount- (oldamlount % 2)); i += 1) {
            newOrder[i] = new Node(oldOrder[i*2], oldOrder[i*2 + 1]);//将原有的结点两两结合成父点
        }
        delete[] oldOrder;
        oldOrder = newOrder;
        oldamlount = newamount;
    }
    Node* ret = oldOrder[0];
    delete[] oldOrder;
    return ret;
}
```

#### 5.1.3存在性证明

存在性证明思路比较简单，只需给出哈希节点路线最终得出根节点即可。

#### 5.1.4不存在证明

不存在证明既要证明两个节点存在，又要证明两个节点在逻辑上是相邻的。

##### 相邻证明

要想证明两个叶子节点在逻辑上相邻的，即证明这两个结点之间不会再有任何新的叶子结点即可。
使用如下算法进行判断：

- 从上往下同时遍历两个结点的路径，直到两个路径开始分叉
- 再遍历左节点的路径，如果有向左的路径，立即返回错误
- 再遍历右节点的路径，如果有向右的路径，立即返回错误
- 返回正确

### 5.2实现效果
- 使用链式存储减少了内存浪费
- 构造10w个叶子节点的Merkel Tree用时151.99毫秒。
- 严格完成了存在性证明以及不存在证明（尤其是相邻性证明）。
- 运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz
- 注意了垃圾回收。确保了内存安全。

## Project6

### 6.1实现方式

使用VS C++编程，哈希函数调用的openssl实现的SHA256.

#### 6.1.1认证机构计算并承诺

认证机构根据证明者实际拥有的数量计算对应次数的哈希并对结果签名。

#### 6.1.2证明者计算数据

证明者根据被证明者要求的数据计算对应的哈希。

#### 6.1.3被证明者验证

被证明者用证明者的数据计算对应次数的哈希，并与认证机构的签名结果相比对。

### 6.2实现效果

在本地模拟了网络中的通信过程，并模拟了认证机构计算并签名承诺、证明者根据要求计算并提供数据、被证明者完成证明的过程。
经验证程序结果正确。

## Project7

### 7.1实现方式

按照该网页https://zkproof.org/2021/05/05/hashwires-range-proofs-from-hash-functions/ 的流程编写C++程序。

流程大体分为5步：

#### 7.1.1确定所有的MDP数
首先设定基数，本次设定为16，位数为8，可表示所有的32bit的数。将待证明的数划为多个区间，算法为：从i=1开始，找到连续最低i位基数为最大且小于原数值的最大的数，直到不能找到这样的数为止。
#### 7.1.2计算hashwires
除最高位之外，其他的位均计算最大基数长的hashwire，计算方法同Project6，将其存放在一个8*16的多维数组h中。随后，根据上个算法确定的所有MPD数，逐位索引出h中对应的hash值，每个MPD数索引得到8个哈希值，将这些哈希值一并加盐再哈希即得到每个MPD数的commit。将所有的commit存在一个数组中。
#### 7.1.3构建padded sparse Merkle tree accumulator
首先确定树的高度，树越高，越能隐藏原有信息。在此选用10.

树的构建不同于Project5,因为这棵树是稀疏的，而Project5中的树近乎于满二叉树，因此在此选择由上往下构建的方式，首先随机出所有commit叶子结点的位置(shuffle)，进而根据shuffle由上往下创建节点，再从下往上对结点填充计算内容，进而计算出根节点，得到根commit.
从下往上填充树的过程算法如下：
1. 将结点分为填充叶子结点和commit叶子结点以及非叶子结点。
2. 从一个commit叶子结点的父结点开始。
3. 如果该节点的子节点为填充叶子结点或commit叶子结点或finishied的非叶子节点，则可计算该节点的值，将其标记为finishied,再从该节点的父节点重复该步骤直到根节点。
4. 否则回到2，换下一个commit叶子结点的父结点。
~~~ c++
for (int j = 0; j < NofMDPs; j++) {
        Node* n = leaf[j]->father;
        while (n != NULL) {
            if (n->lchild->finished == false && n->lchild->pad == true) {
                generateRandomArray(n->lchild->hash, Hashlength);
                n->lchild->finished = true;
            }
            if (n->rchild->finished == false && n->rchild->pad == true) {
                generateRandomArray(n->rchild->hash, Hashlength);
                n->rchild->finished = true;
            }
            if (n->lchild->finished == false || n->rchild->finished == false)
                break;
            else
            {
                unsigned char tmp[Hashlength * 2];
                memcpy(tmp, n->lchild->hash, Hashlength);
                memcpy(tmp + Hashlength, n->rchild->hash, Hashlength);
                SHA256(tmp, Hashlength * 2, n->hash);
                n->finished = true;
                n = n->father;
            }
        }
    }
~~~

可以证明这个算法一定能计算出根节点
而且该算法的时间复杂度为树的高度乘以结点数量。
若采用Project5中的构建方法，则复杂度为二的树的高度次幂。
#### 7.1.4给出证明
根据被证明者的要求选出MDP树，并且将计算后的hashwires以及Merkle tree的证明路径发送给被证明者。
#### 7.1.5验证证明
被证明者计算出hashwires，加盐哈希后按路径得到根commit.即可完成证明。
### 7.2实现效果
- 严格按照原文的流程实现了所有的算法，保证了证明过程的零知识性。
- 确保的算法的时间复杂度较小，（尤其是构建Merkel Tree的算法）保证了运行效率。
- 在C++程序编写时特别注意了内存安全。
- 多次运行验证了算法的正确性。
#### 时间测试
完整流程运行时间为1.7毫秒，包括承诺者的承诺生成过程但不包括承诺者的数字签名过程以及网络通信过程。
运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz

# report on the application of this deduce technique in Ethereum with ECDSA

此project的内容：有关“从签名推出公钥”这一技术在以太坊中的应用的调研报告。具体内容请见文件report.md。
