## Project1

### 生日攻击原理

假设有一个函数f，它的输出范围是[0,2^n]，那么我们的攻击就是找到两个不同的x，y，让f(x)=f(y)。这时候，我们可以称x和y发生了碰撞。根据概率论的公式，我们想要达到50%的几率，那么需要尝试的次数是2^(n/2)。 
### 实现思路

我们寻找hash函数值的28位的碰撞。首先创建一个大小为2^(28)的数组：

```c++
unsigned short arr[ 2 << 28];
```

将其全都初始化为0。

然后对unsigned int 类型的变量i进行hash。实现方式如下：

```c++
std::string str = std::to_string(i);//转化为字符串
unsigned int message_len = strlen(str.c_str());
unsigned char hash[EVP_MAX_MD_SIZE];
unsigned int hash_len;
EVP_Digest(str.c_str(), message_len, hash, &hash_len, EVP_sm3(), NULL);
```

hash值结果存于hash[]中。

unsigned char 类型大小为8位，为得到28位，我们取hash[0],hash[1],hash[2],hash[3],将其合并为一个32位usigned int类型的数，并和28位1进行与运算，得到28位的hash值。实现方式如下：

```c++
int hash28(char a, char b, char c, char d)
{
	std::bitset<8> binary0(a);
	//std::cout << binary0 << std::endl;
	std::bitset<8> binary1(b);
	//std::cout << binary1 << std::endl;
	std::bitset<8> binary2(c);
	//std::cout << binary2 << std::endl;
	std::bitset<8> binary3(d);
	//std::cout << binary3 << std::endl;

	unsigned int num0 = static_cast<unsigned int>(binary0.to_ulong());
	unsigned int num1 = static_cast<unsigned int>(binary1.to_ulong());
	unsigned int num2 = static_cast<unsigned int>(binary2.to_ulong());
	unsigned int num3 = static_cast<unsigned int>(binary3.to_ulong());

	int tem1 = (num0 << 24) | (num1 << 16) | (num2 << 8) | num3;

	int mask = (1 << 28) - 1;  // 28 位全为 1 的数
	int tem2 = tem1 & mask;
	return tem2;
}
```

我们采取空间换取时间的方式，每对一个i进行hash，得到28位值x，就令arr[x]=i。这样我们每得到一个值，只需要检测hash[x]是否等于0即可。如果不等于0，那么得到碰撞，两个原像分别为i和arr[x]。如果等于0，就令arr[x]=i。实现过程如下：

```c++
int tem = hash28(hash[0], hash[1], hash[2], hash[3]);
if (arr[tem] != 0)
{
	cout << "找到碰撞，原像为" << i << "和" << arr[tem] << endl;
	cout << "hash值的28位";
	//cout<<tem << endl;
	std::bitset<32> binary5(tem);

	std::cout << binary5 << std::endl;
	clock_t end = clock();

	double endtime = (double)(end - start) / CLOCKS_PER_SEC;

	cout << "寻找hash值28位碰撞花费时间:" << endtime * 1000 << "ms(忽略前四位全0)" << endl;    //ms为单位
	system("pause");
	return 0;
}
else
{
	arr[tem] = i;
}
```

### 实验结果


|   位数   |  28bits  |
| :------: | :------: |
| **时间** | **53ms** |




## Project2

### ρ攻击原理

ρ 攻击利用了 SM3 压缩函数中的非线性变换部分，通过构造一组具有特殊结构的输入，使得压缩函数在处理这些输入时，会产生一些特殊的状态。在这些特殊的状态下，压缩函数的输出值会重复出现，从而导致不同的输入最终产生相同的哈希值。

### 实现过程

我们寻找hash函数值的32位的碰撞。

首先，对unsigned int 类型的变量i进行hash的实现方式如下：

```c++
std::string str = std::to_string(x);//转化为字符串
//unsigned int message_len = strlen(str.c_str());

unsigned char hash[EVP_MAX_MD_SIZE];
unsigned int hash_len;

EVP_Digest(str.c_str(), 256, hash, &hash_len, EVP_sm3(), NULL);
```

为得到32位碰撞，我们取四个unsigned char 类型的hash[i]，并将其拼接为一个unsigned int 类型的变量：

```c++
unsigned int join4(unsigned int a, unsigned int b, unsigned int c, unsigned int d)
{
	return ((a << 24) | (b << 16) | (c << 8) | d);
}
```

为接住函数返回的四个hash[i]，我们创建结构体four，并将hash过程写为一个函数，返回一个four类型的结构体：

```c++
struct four {
	unsigned int a;
	unsigned int b;
	unsigned int c;
	unsigned int d;
};


four hash_4(unsigned int x)
{
	four tem;
	std::string str = std::to_string(x);//转化为字符串
	unsigned int message_len = strlen(str.c_str());

	unsigned char hash[EVP_MAX_MD_SIZE];
	unsigned int hash_len;

	EVP_Digest(str.c_str(), 256, hash, &hash_len, EVP_sm3(), NULL);
	tem.a = (unsigned int)hash[0];
	tem.b = (unsigned int)hash[1];
	tem.c = (unsigned int)hash[2];
	tem.d = (unsigned int)hash[3];
	return tem;
}

```

循环主体如下：

```c++
for (int i = 0; i < ; i++)
	{

		if (tem1.a == tem2.a && tem1.b == tem2.b && tem1.c == tem2.c&&tem1.d==tem2.d)
		{
			cout << "找到32位碰撞" << endl;
			cout << "前32位为0x" << hex << tem1.a << hex << tem1.b << hex << tem1.c << hex << tem1.d << endl;
			cout << "前32位为0x" << hex << tem2.a << hex << tem2.b << hex << tem2.c << hex << tem2.d << endl;
			cout << "循环" << dec << i << "次" << endl;
			clock_t end = clock();
			double endtime = (double)(end - start) / CLOCKS_PER_SEC;
			cout << "寻找hash值32位碰撞花费时间:" << endtime * 1000 << "ms" << endl;    //ms为单位
			//system("pause");
			return 0;
		}
		else
		{
			tem1 = hash_4(result1);
			result1 = join4(tem1.a, tem1.b, tem1.c,tem1.d);


			tem2 = hash_4(result2);
			result2 = join4(tem2.a, tem2.b, tem2.c,tem2.d);
			tem2 = hash_4(result2);
			result2 = join4(tem2.a, tem2.b, tem2.c,tem2.d);

			/*if (i % 100 == 0)
			{
				cout << result1 << endl << result2 << endl;
			}*/
		}

	}
```

### 实现结果


| 位数         | 32bits       |
| ------------ | ------------ |
| **循环次数** | **121109次** |
| **时间**     | **678ms**    |


## Project4
### 实现方式
主要使用SIMD指令对SM3的消息扩展的阶段进行了加速。
### 实现效果
