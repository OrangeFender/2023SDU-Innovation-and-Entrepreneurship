## Project1
由张云帆完成，最终找到56bit碰撞。

### 1.0 生日攻击原理

生日攻击的核心在于用空间换时间，将所有的哈希值都保存下来，每次计算新的哈希值都判断与之前计算过的是否相同。

### 1.1 实现思路

我们首先确定短期找到碰撞的数量级不太可能超过60bit。
因此将原像的空间限定在了32bit，使用uint32类型表示一个原像。
- 建立一个原像的数组，将数组索引来表示hash值的前导32位。
- 数组初始化为全0.
- 根据hash结果索引到数组的某个值，如果为0则将值改成原像，如果不是0，则说明找到碰撞。
#### 1.1.0 内存数组实现
首先在内存中编写程序，发现一般的程序最多申请 $2^{28}$ 长的数组，因此将原像空间限定在unsigned short.

部分代码如下：

```c++
int hash28(char a, char b, char c, char d);
int tem = hash28(hash[0], hash[1], hash[2], hash[3]);
if (arr[tem] != 0)
{
    cout << "找到碰撞，原像为" << i << "和" << arr[tem] << endl;
    cout << "hash值的28位";
    //cout<<tem << endl;
    std::bitset<32> binary5(tem);

    std::cout << binary5 << std::endl;
    clock_t end = clock();

    double endtime = (double)(end - start) / CLOCKS_PER_SEC;

    cout << "寻找hash值28位碰撞花费时间:" << endtime * 1000 << "ms(忽略前四位全0)" << endl;    //ms为单位
    system("pause");
    return 0;
}
else
{
    arr[tem] = i;
}
```

内存版程序实验结果

| 位数     | 28bits   |
|:------:|:--------:|
| **时间** | **53ms** |

发现运行时间实在太短，说明空间严重不足，因此需要将存储转移到硬盘中。

#### 1.1.1 硬盘实现以找到更长的碰撞
尝试找到长度更大的碰撞，因此将数组存储在了硬盘中。申请一个16Gbyte的文件，可以相当于 ` uint32 [1<<32] `的数组。

使用`windows.h`的`CreateFileMappingA`方法,可以将文件映射在虚拟的内存空间中，进而正常的索引读取即可。

之后使用上小节的方法即可找出碰撞，碰撞长度为32位。
##### 运行结果
除去初始化16Gbyte的时间，只需两秒即可找到32bit的碰撞，结果见文件夹内的截图。
#### 1.1.1.1
时间依旧太短，因此尝试找到更长的碰撞。

在此使用了新的思路，只需用原方法找到大量的32bit碰撞，其中就可能会含有更长长度的碰撞。
因此在原有代码下增加新的判断即可，代码节选如下:
~~~ C
    printf("try to find more collision\n");
    int best = 0;
    uint32_t i = 1; unsigned long long ind;
    uint32_t best1, best2;
    for (i = 1; i > 0; i++) {
        ind = hash_out4byte(i);
        if (pData[ind] != 0) {
            uint32_t v = pData[ind];
            unsigned char hash1[EVP_MAX_MD_SIZE];
            unsigned char hash2[EVP_MAX_MD_SIZE];
            unsigned int hash_len;
            //printf("The 32bit of the collision is:%x\n", ind);
            //printf("The original image is:%x\nSM3 is:", i); printhash(4, &i);
            //printf("The original image is:%x\nSM3 is:", v); printhash(4, &v);
            EVP_Digest(&v, 4, hash1, &hash_len, EVP_sm3(), NULL);
            EVP_Digest(&i, 4, hash2, &hash_len, EVP_sm3(), NULL);
            int sameBits=countConsecutiveSameBits(hash1, hash2, 32);
            //printf("%d\n", sameBits);
            if (best < sameBits) {
                best = sameBits;
                printf("find %d bits collision\n", best);
                best1 = v;
                best2 = i;
            }
            //if (best > 40)
            //    break;
        }
        pData[ind] = i;
    }
    printf("best collision is %d bits\n", best);
    printf("The original image is:%x\nSM3 is:", best1); printhash(4, &best1);
    printf("The original image is:%x\nSM3 is:", best2); printhash(4, &best2);
~~~
结果见1.2节

#### 1.1.2 关于虚拟内存（内存与硬盘）
做完实验意识到，虚拟内存可以类似地完成上面的工作，多次动态申请数组可以完成上面的工作，但是这两种方式的实际效果应该是差不多的，因为读取方式是完全随机的，内存只是缓存作用。
#### 1.1.3 关于字典
`std::map`提供了基于红黑树的字典结构，尝试用此替代数组，可以节省空间开销，代码如下(文件birthday_attack_map.cpp):
~~~C++
int main() {
    std::map<uint64_t, uint64_t> myMap;
    for (uint64_t i = 1; i < MAsk; i++) {
        uint64_t h = hash_masked(i, MAsk);
        std::map<uint64_t, uint64_t>::iterator iter = myMap.find(h);
        if (iter != myMap.end()) {
            uint64_t m = iter->second;
            std::cout << "m1=" << std::hex<< m << std::endl;
            std::cout << "hash:\n";
            printhash(8, &m);
            std::cout << "m2=" << std::hex<< i << std::endl;
            std::cout << "hash:\n";
            printhash(8, &i);
            break;
        }
        else {
            myMap[h] = i;
        }
    }
    return 0;
}
~~~
结果发现使用字典寻找48bit内的碰撞效果较好，然而超过48bit，存储量大大上升，索引过程变慢，因此没有再尝试。主要原因是索引时间与碰撞长度成正比；
而对于之前的数组索引法，索引过程时间复杂度为常数。
### 1.2 实现效果
最佳方案为在硬盘中的数组索引法，实现了时间和存储的权衡，最终在`10小时内`找到了`56bit`的碰撞：
~~~
The original image is:19987c6c

SM3 is:85818ebdd1144d2b54bfa999e59b03a614427c997f759b354621fe29ee1479

The original image is:19912e35

SM3 is:85818ebdd11445e643e439871a5bce88e6deb63fac5846d7251937264b6775
~~~
运行结果见文件夹内的截图。

由于空间占用为16Gbyte，硬盘性能应该为性能瓶颈。

硬盘为KIOXIA-EXCERIA G2 SSD PCIe 3.0 x4

运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz

## Project2
由张云帆完成,找到64bit碰撞
### 2.1 ρ攻击原理
从一个起点开始，不停的计算哈希值，结果一定会落入一个循环中，我们记循环的周期为 $b$ ，循环前的路径长度为 $a$ .

我们的目的是找到环与起始路径相切的点，即为碰撞点。

建立两个变量，从相同起点开始，迭代更新自己为自己的值的哈希值，一个步一次迭代一次，另一个一步迭代两次，则经过 $x$ 次哈希和经过 $2x$ 次哈希后，两个重新回到了圆环上的某个相同点，假设该点在碰撞点后的第 $y$ 个， $n$ 为未知正整数，我们有如下关系式：
$$x=a+y$$
$$2x=a+nb+y$$
进而可得
$$y+a=nb$$
可以发现，刚才得到的相同点开始再迭代 $a$ 次即可得到碰撞点，但是我们不知道 $a$ 的值。
幸运的是，只需再从分别起点和刚才找到的相同点开始，共同迭代相同的次数，就能在碰撞点相遇，这个次数即为 $a$ .
#### 2.1.2 实现方式
给出部分关键代码
~~~C
    long long h1 = start;
    long long h2 = start;
    do {
        h1 = hash_masked(h1, MAsk);
        h2 = hash_masked(h2, MAsk);
        h2 = hash_masked(h2, MAsk);
    } while (h2!=h1);
    std::cout << "find circle" << std::endl;
    h1 = start;
    while (true) {
        long long tmp1, tmp2;
        tmp1 = hash_masked(h1, MAsk);
        tmp2 = hash_masked(h2, MAsk);
        if (tmp1 == tmp2) {
            std::cout << "m1=" << std::hex << h1 <<std::endl;
            printhash(8, &h1);
            std::cout << "m2=" << std::hex << h2 << std::endl;
            printhash(8, &h2);
            return 0;
        }
        h1 = tmp1;
        h2 = tmp2;

    }
~~~
### 2.2 实现结果
在约十分钟内找到了56bit的碰撞。具体如下，输入长度为八字节(long long),前7字节为碰撞:
~~~
m1=2fffba784f224a
f7f3adc92316199df2a5b44b7bebafa3f1ee8f4eb946b0cb1afb4c57c88db5
m2=3bf9f2529b13dd
f7f3adc9231619f1eda382cb8546d0ed4accfd98feede7fcff87e28d27443
~~~
后来修改了参数，寻找64bit的碰撞，输入长度为八字节(long long),用时约6小时找到了64bit的碰撞，前8字节为碰撞:
~~~
m1=812906f5c8a7faoe
f09dd5662ecd5d947eced349b05885ffa999814363cd945c3395e8e73f8d7af9
m2=5c4830693bc6664a
f09dd5662ecd5d94d0316dc66a3edbb12a143b643e693cae68167f176354c33b
~~~

## Project3
张云帆完成
### 3.1实现方式
对自己在prj4实现的sm3进行修改即可实现长度扩展攻击。

SM3为md结构，长度扩展攻击即为将已知输入长度的哈希值作为新一轮SM3的初始向量，输入新的要扩展的信息，注意填充的长度值为新信息的长度加上原输入pad后的长度，计算结果即为pad后的原输入级联新信息的哈希值。

在本项目中，用字符串`"the unkown message"`替代未知信息，用`"the message to attach"`替代扩展的信息。
先仅使用未知信息的哈希进行长度扩展攻击，再使用未知信息用常规SM3计算扩展后的哈希值，将两者进行比对即可。

主要代码如下:
~~~C++
int main() {
    const char* message1 = "the unkown message";
    int M1len_after_pad=64;
    unsigned char M1[64];//用于存储填充后的信息
    unsigned char h1[32];
    SM3(19, message1,M1,h1);
    for (int i = 0; i < 32; i++) {
        ((UINT32*)M1)[i] = swap32(((UINT32*)M1)[i]);
    }
    std::cout << "h1=:";
    for (int i = 0; i < 32; i++) {
        std::cout << std::hex<<(int)h1[i];
    }
    std::cout << std::endl;
    const char* attached="the message to attach";
    unsigned char M2[64];
    unsigned char h2[32];
    lengthattack((UINT32*)h1, 64, attached, M2, 22, h2);
    std::cout << "h2=:";
    for (int i = 0; i < 32; i++) {
        std::cout << std::hex<< (int)h2[i];
    }
    std::cout << std::endl;
    int new_messagelen = M1len_after_pad + 22;
    char* m = new char[new_messagelen];
    memcpy(m, M1, 64);
    memcpy(m + 64, attached, 22);
    unsigned char M_[128];
    unsigned char h3[32];
    SM3(new_messagelen, m, M_, h3);
    std::cout << "confirm h3=:" << std::endl;
    for (int i = 0; i < 32; i++) {
        std::cout << std::hex<< (int)h3[i];
    }
    std::cout << std::endl;
    delete[] m;
}
~~~
### 3.2 实现结果
程序输出如下:
~~~
h1=:6aebdafa44d532a7bbe041e469b5254d757b3924440ba0902fe65878f7b9
h2=:817e33bf2f48f63f9054b8594f1834ad988c5fa3b6801ad5f926c4cfdfd81
confirm h3=:
817e33bf2f48f63f9054b8594f1834ad988c5fa3b6801ad5f926c4cfdfd81
~~~
经检验攻击正确。
## Project4
由张云帆完成
### 4.1 实现方式

消息填充阶段的实现在此省略。下面主要介绍使用的优化方案。

#### 4.1.0 失败的SIMD优化

我们首先观察消息扩展阶段的数据依赖情况，发现每个新字需要依赖后面第三个字之前的字，因此我们可以并行的进行消息扩展，每次生成三个新字。
在此使用x86的AVX指令集。
在此将7个m128i变量当作寄存器使用，并考虑了乱序执行：
```C
        va = _mm_loadu_si128((__m128i*)(W + j - 16));
        vb = _mm_loadu_si128((__m128i*)(W + j - 9));
        vc = _mm_loadu_si128((__m128i*)(W + j - 3));
        vd = _mm_loadu_si128((__m128i*)(W + j - 13));
        vl = _mm_slli_epi32(vc, 15);
        vr = _mm_srli_epi32(vc, 32 - 15);
        va = _mm_xor_si128(va, vl);
        vr = _mm_xor_si128(vr, vb);//(vc<<<15)⊕va⊕vb
        ve = _mm_load_si128((__m128i*)(W + j - 6));
        vc = _mm_xor_si128(va, vr);//vc=Wj−16 ⊕ Wj−9 ⊕ (Wj−3 <<< 15)
        vl = _mm_slli_epi32(vc, 15);
        vr = _mm_srli_epi32(vc, 32 - 15);
        va = _mm_slli_epi32(vc, 23);
        vl = _mm_xor_si128(vl, vr);
        vb = _mm_srli_epi32(vc, 32 - 23);
        vc = _mm_xor_si128(vc, vl);
        va = _mm_xor_si128(vb, va);
        vl = _mm_slli_epi32(vd, 7);
        vc = _mm_xor_si128(va, vc);
        vr = _mm_srli_epi32(vd, 32 - 7);
        vc = _mm_xor_si128(vc, vl);
        ve = _mm_xor_si128(ve, vr);
        vc = _mm_xor_si128(ve, vc);
        _mm_storeu_si128((__m128i*)(W + j), vc);
```
经过编译，程序运行结果较慢，计算33554432字节的全零数组需要160ms，重新用普通方法实现了一次，结果优于该方案，为140ms，因此该方案被弃用。
#### 4.1.1 重新考虑SIMD优化策略
经查阅资料，发现m128i寄存器在读取非128bit对齐的数据时效率非常低。而且每次生成三个新字其实浪费了很多算力。

再次观察消息扩展阶段的表达式，发现其所有运算为移位和异或，因此具有分配和交换律，所以可以一次运算四个新数w0,w1,w2,w3,计算w3所依赖的w0暂时用0代替，等四个数都算完后在读取w0和w3计算出正确的w3即可。

但是这样的运算弊端也很明显，每并行算出四个数后还需单独计算一个数，好在单独的计算并不需要从头开始算。
具体代码如下:
~~~C
    __m128i va, vb, vc, vd, ve;
    const __m128i vmask = _mm_set_epi32(0, 0xffffffff, 0xffffffff, 0xffffffff);
    for (int j = 16; j < 32; j += 4) {
        vc = _mm_loadu_si128((__m128i*)(W + j - 3));
        va = _mm_load_si128((__m128i*)(W + j - 16));
        vb = _mm_loadu_si128((__m128i*)(W + j - 9));
        //vc = _mm_setr_epi32(0, W[j - 3 + 2], W[j - 3 + 1], W[j - 3]);
        vd = _mm_loadu_si128((__m128i*)(W + j - 13));
        vc = _mm_and_si128(vc, vmask);
        ve = _mm_loadu_si128((__m128i*)(W + j - 6));

        __m128i tmp1 = _mm_xor_si128(_mm_xor_si128(va, vb), rotate_left_epi32(vc, 15));
        __m128i tmp2 = _mm_xor_si128(_mm_xor_si128(rotate_left_epi32(tmp1, 15), rotate_left_epi32(tmp1, 23)), tmp1);
        __m128i tmp3 = _mm_xor_si128(tmp2, _mm_xor_si128(rotate_left_epi32(vd, 7), ve));
        _mm_store_si128((__m128i*)(W + j), tmp3);
        UINT32 t = LeftRotate(W[j], 15);
        W[j + 3] = W[j + 3] ^ t ^ LeftRotate(t, 15) ^ LeftRotate(t, 23);
~~~
经过测量，效果要优于上个优化方式。

#### 4.1.2 避免判断
SM3描述的消息压缩阶段需要对当前轮数判断，以选择不同的布尔函数和常量，可以直接将代码分成两部分，前16轮为一个循环，后48轮为一个循环
#### 4.1.3 硬编码
消息压缩阶段有对常数T移位的操作，可以提前将其移位存储在代码中。
#### 4.1.4 流水线优化
发现消息扩展需要不断的对内存读写更新，这是不利于CPU流水线操作的，因此可以将4字消息扩展完成后立即进行4次消息压缩，如此循环。
#### 4.1.5 编译器优化
使用编译器进行函数内联以及unroll

如此完整的消息扩展和压缩过程如下:
~~~C
void round(UINT32 b[16], UINT32 W[68 + 3], UINT32 V[8]) {
    memcpy(W, b, 16 * 4);
   

    UINT32 A, B, C, D, E, F, G, H, SS1, SS2, TT1, TT2;
    A = V[0]; B = V[1]; C = V[2]; D = V[3]; E = V[4]; F = V[5]; G = V[6]; H = V[7];
    
    __m128i va, vb, vc, vd, ve;
    const __m128i vmask = _mm_set_epi32(0, 0xffffffff, 0xffffffff, 0xffffffff);
#pragma loop(hint_parallel(4))
    for (int j = 16; j < 32; j += 4) {
        vc = _mm_loadu_si128((__m128i*)(W + j - 3));
        va = _mm_load_si128((__m128i*)(W + j - 16));
        vb = _mm_loadu_si128((__m128i*)(W + j - 9));
        //vc = _mm_setr_epi32(0, W[j - 3 + 2], W[j - 3 + 1], W[j - 3]);
        vd = _mm_loadu_si128((__m128i*)(W + j - 13));
        vc = _mm_and_si128(vc, vmask);
        ve = _mm_loadu_si128((__m128i*)(W + j - 6));

        __m128i tmp1 = _mm_xor_si128(_mm_xor_si128(va, vb), rotate_left_epi32(vc, 15));
        __m128i tmp2 = _mm_xor_si128(_mm_xor_si128(rotate_left_epi32(tmp1, 15), rotate_left_epi32(tmp1, 23)), tmp1);
        __m128i tmp3 = _mm_xor_si128(tmp2, _mm_xor_si128(rotate_left_epi32(vd, 7), ve));
        _mm_store_si128((__m128i*)(W + j), tmp3);
        UINT32 t = LeftRotate(W[j], 15);
        W[j + 3] = W[j + 3] ^ t ^ LeftRotate(t, 15) ^ LeftRotate(t, 23);

#pragma loop(hint_parallel(4))
        for (int i = 0; i < 4; i++) {
            SS1 = LeftRotate((LeftRotate(A, 12) + E + Tj[j-16+i]), 7);
            SS2 = SS1 ^ LeftRotate(A, 12);
            TT1 = FF1(A, B, C) + D + SS2 + (W[j-16+i]^ W[j - 16 + i+4]);
            TT2 = GG1(E, F, G) + H + SS1 + W[j-16+i];
            D = C;
            C = LeftRotate(B, 9);
            B = A;
            A = TT1;
            H = G;
            G = LeftRotate(F, 19);
            F = E;
            E = p0(TT2);
            //printf("%d A:%x B:%x C:%x D:%x E:%x F:%x G:%x H:%x \n",j-16+i, A, B, C, D, E, F, G, H);
        }
    }
#pragma loop(hint_parallel(9))
    for (int j = 32; j < 68; j += 4) {
        vc = _mm_loadu_si128((__m128i*)(W + j - 3));
        va = _mm_load_si128((__m128i*)(W + j - 16));
        vb = _mm_loadu_si128((__m128i*)(W + j - 9));
        //vc = _mm_setr_epi32(0, W[j - 3 + 2], W[j - 3 + 1], W[j - 3]);
        vd = _mm_loadu_si128((__m128i*)(W + j - 13));
        vc = _mm_and_si128(vc, vmask);
        ve = _mm_loadu_si128((__m128i*)(W + j - 6));
        __m128i tmp1 = _mm_xor_si128(_mm_xor_si128(va, vb), rotate_left_epi32(vc, 15));
        __m128i tmp2 = _mm_xor_si128(_mm_xor_si128(rotate_left_epi32(tmp1, 15), rotate_left_epi32(tmp1, 23)), tmp1);
        __m128i tmp3 = _mm_xor_si128(tmp2, _mm_xor_si128(rotate_left_epi32(vd, 7), ve));
        _mm_store_si128((__m128i*)(W + j), tmp3);

        UINT32 t = LeftRotate(W[j], 15);
        W[j + 3] = W[j + 3] ^ t ^ LeftRotate(t, 15) ^ LeftRotate(t, 23);

#pragma loop(hint_parallel(4))
        for (int i = 0; i < 4; i++) {
            int ind = j - 16 + i;
            SS1 = LeftRotate((LeftRotate(A, 12) + E + Tj[j-16+i]), 7);
            SS2 = SS1 ^ LeftRotate(A, 12);
            //printf("W:%x,%x\n", W[j - 16 + i], W[j - 16 + i + 4]);
            TT1 = FF2(A, B, C) + D + SS2 + (W[j - 16 + i] ^ W[j - 16 + i + 4]);
            TT2 = GG2(E, F, G) + H + SS1 + W[j-16+i];
            D = C;
            C = LeftRotate(B, 9);
            B = A;
            A = TT1;
            H = G;
            G = LeftRotate(F, 19);
            F = E;
            E = p0(TT2);
            //printf("%d A:%x B:%x C:%x D:%x E:%x F:%x G:%x H:%x \n", j - 16 + i, A, B, C, D, E, F, G, H);
        }
    }
#pragma loop(hint_parallel(12))
    for (int j = 68-16; (j) < 64; j++) {
        SS1 = LeftRotate((LeftRotate(A, 12) + E + Tj[j]), 7);
        SS2 = SS1 ^ LeftRotate(A, 12);
        TT1 = FF2(A, B, C) + D + SS2 +( W[j] ^ W[j + 4]);
        TT2 = GG2(E, F, G) + H + SS1 + W[j];
        D = C;
        C = LeftRotate(B, 9);
        B = A;
        A = TT1;
        H = G;
        G = LeftRotate(F, 19);
        F = E;
        E = p0(TT2);
        //printf("%d A:%x B:%x C:%x D:%x E:%x F:%x G:%x H:%x \n",j, A, B, C, D, E, F, G, H);
    }
    
    V[0] ^= A; V[1] ^= B; V[2] ^= C; V[3] ^= D; V[4] ^= E; V[5] ^= F; V[6] ^= G; V[7] ^= H;
}
~~~
### 4.2 实现效果
#### 4.2.1 正确性
与openssl的实现速度进行对比，计算33554432字节的全零数组的哈希经比较实现结果**完全正确**。
编译好的程序已经在VS工程目录下的\x64\release文件夹下

#### 4.2.2 时间对比
经过多次优化，最终的实现效果与openssl的效果基本一致，同样计算33554432字节的全零数组，二者的时间基本一致，但是openssl的代码似乎没有使用simd优化，在此说明simd的优化效果微乎其微。
主要原因是：
- 消息扩展阶段的数据依赖性太强，无法完全地四字并行。
- 对于普通的寄存器，有直接循环移位的rol指令，但是avx没有对向量的循环移位指令，因此每次循环移位都需要三个指令完成。

运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz
||自己的实现|openssl|
|---|---|---|
|时间（毫秒）|113.48|113.54|

运行结果截图见文件。

## Project5
由张云帆完成
### 5.1实现方式

使用VS C++编程，哈希函数调用的openssl实现的SHA256.

#### 5.1.1索引方式

看到Merkel Tree的结构，首先想到的是将其用一个满二叉树的索引表示，但是由于叶子节点是从左往右从下往上排列的，因此这样最多会造成一半的存储空间的浪费。

```C++
class Node {
public:
    unsigned char hash[hashlength];
    Node* father;
    Node* lchild;
    Node* rchild;
    transection* son;
    bool isleftchild() {
        return father->lchild == this;
    }
};

```

最终选择了链式存储，由于要从下往上索引，因此加入了父指针。

#### 5.1.2构建方式

采用循环的方式构建二叉树，从最底层开始，如果结点数组的数目是奇数，复制最后一个结点，并将其添加到列表末尾，再创建新结点数组，将原有的结点两两结合成父点。

结点数组是指针数组，便于动态内存管理。

```C++
Node* build(int amount, transection* trans) {
    int oldamlount=amount;
    Node** oldOrder = new Node*[oldamlount];
    for (int i = 0; i < oldamlount; i++)
        oldOrder[i] =new Node(&trans[i]);
    Node** newOrder;
    while (oldamlount > 1) {
        int newamount = (oldamlount + 1) >> 1;
        newOrder = new Node*[oldamlount];
        if (oldamlount % 2) {
            newOrder[newamount-1] = oldOrder[oldamlount -1];//如果结点数组的数目是奇数，复制最后一个结点，并将其添加到列表末尾
        }
        for (int i = 0; i < (newamount- (oldamlount % 2)); i += 1) {
            newOrder[i] = new Node(oldOrder[i*2], oldOrder[i*2 + 1]);//将原有的结点两两结合成父点
        }
        delete[] oldOrder;
        oldOrder = newOrder;
        oldamlount = newamount;
    }
    Node* ret = oldOrder[0];
    delete[] oldOrder;
    return ret;
}
```

#### 5.1.3存在性证明

存在性证明思路比较简单，只需给出哈希节点路线最终得出根节点即可。

#### 5.1.4不存在证明

不存在证明既要证明两个节点存在，又要证明两个节点在逻辑上是相邻的。

##### 相邻证明

要想证明两个叶子节点在逻辑上相邻的，即证明这两个结点之间不会再有任何新的叶子结点即可。
使用如下算法进行判断：

- 从上往下同时遍历两个结点的路径，直到两个路径开始分叉
- 再遍历左节点的路径，如果有向左的路径，立即返回错误
- 再遍历右节点的路径，如果有向右的路径，立即返回错误
- 返回正确

### 5.2实现效果
- 使用链式存储减少了内存浪费
- 构造10w个叶子节点的Merkel Tree用时151.99毫秒。
- 严格完成了存在性证明以及不存在证明（尤其是相邻性证明）。
- 运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz
- 注意了垃圾回收。确保了内存安全。

## Project6
由张云帆完成
### 6.1实现方式

使用VS C++编程，哈希函数调用的openssl实现的SHA256.

#### 6.1.1认证机构计算并承诺

认证机构根据证明者实际拥有的数量计算对应次数的哈希并对结果签名。

#### 6.1.2证明者计算数据

证明者根据被证明者要求的数据计算对应的哈希。

#### 6.1.3被证明者验证

被证明者用证明者的数据计算对应次数的哈希，并与认证机构的签名结果相比对。

### 6.2实现效果

在本地模拟了网络中的通信过程，并模拟了认证机构计算并签名承诺、证明者根据要求计算并提供数据、被证明者完成证明的过程。
经验证程序结果正确。

## Project7
由张云帆完成
### 7.1实现方式

按照该网页https://zkproof.org/2021/05/05/hashwires-range-proofs-from-hash-functions/ 的流程编写C++程序。

流程大体分为5步：

#### 7.1.1确定所有的MDP数
首先设定基数，本次设定为16，位数为8，可表示所有的32bit的数。将待证明的数划为多个区间，算法为：从i=1开始，找到连续最低i位基数为最大且小于原数值的最大的数，直到不能找到这样的数为止。
#### 7.1.2计算hashwires
除最高位之外，其他的位均计算最大基数长的hashwire，计算方法同Project6，将其存放在一个8*16的多维数组h中。随后，根据上个算法确定的所有MPD数，逐位索引出h中对应的hash值，每个MPD数索引得到8个哈希值，将这些哈希值一并加盐再哈希即得到每个MPD数的commit。将所有的commit存在一个数组中。
#### 7.1.3构建padded sparse Merkle tree accumulator
首先确定树的高度，树越高，越能隐藏原有信息。在此选用10.

树的构建不同于Project5,因为这棵树是稀疏的，而Project5中的树近乎于满二叉树，因此在此选择由上往下构建的方式，首先随机出所有commit叶子结点的位置(shuffle)，进而根据shuffle由上往下创建节点，再从下往上对结点填充计算内容，进而计算出根节点，得到根commit.
从下往上填充树的过程算法如下：
1. 将结点分为填充叶子结点和commit叶子结点以及非叶子结点。
2. 从一个commit叶子结点的父结点开始。
3. 如果该节点的子节点为填充叶子结点或commit叶子结点或finishied的非叶子节点，则可计算该节点的值，将其标记为finishied,再从该节点的父节点重复该步骤直到根节点。
4. 否则回到2，换下一个commit叶子结点的父结点。
~~~ c++
for (int j = 0; j < NofMDPs; j++) {
        Node* n = leaf[j]->father;
        while (n != NULL) {
            if (n->lchild->finished == false && n->lchild->pad == true) {
                generateRandomArray(n->lchild->hash, Hashlength);
                n->lchild->finished = true;
            }
            if (n->rchild->finished == false && n->rchild->pad == true) {
                generateRandomArray(n->rchild->hash, Hashlength);
                n->rchild->finished = true;
            }
            if (n->lchild->finished == false || n->rchild->finished == false)
                break;
            else
            {
                unsigned char tmp[Hashlength * 2];
                memcpy(tmp, n->lchild->hash, Hashlength);
                memcpy(tmp + Hashlength, n->rchild->hash, Hashlength);
                SHA256(tmp, Hashlength * 2, n->hash);
                n->finished = true;
                n = n->father;
            }
        }
    }
~~~

可以证明这个算法一定能计算出根节点
而且该算法的时间复杂度为树的高度乘以结点数量。
若采用Project5中的构建方法，则复杂度为二的树的高度次幂。
#### 7.1.4给出证明
根据被证明者的要求选出MDP树，并且将计算后的hashwires以及Merkle tree的证明路径发送给被证明者。
#### 7.1.5验证证明
被证明者计算出hashwires，加盐哈希后按路径得到根commit.即可完成证明。
### 7.2实现效果
- 严格按照原文的流程实现了所有的算法，保证了证明过程的零知识性。
- 确保的算法的时间复杂度较小，（尤其是构建Merkel Tree的算法）保证了运行效率。
- 在C++程序编写时特别注意了内存安全。
- 多次运行验证了算法的正确性。
#### 时间测试
完整流程运行时间为1.7毫秒，包括承诺者的承诺生成过程但不包括承诺者的数字签名过程以及网络通信过程。
运行设备CPU为AMD Ryzen 5 5600U with Radeon Graphics            2.30 GHz

## Project10

此project的内容：有关“从签名推出公钥”这一技术在以太坊中的应用的调研报告。具体内容请见文件report.md。

## Project11

### RFC6962

当生成ECDSA签名时，需要保证 $k$ 是保密且唯一的。 $k$ 值重复（弱伪随机）可能导致私钥泄露。

因此在本次实验中令k=hash(M||dA)，其中dA为私钥，hash函数为 sm3算法。

### SM2签名算法

#### 签名算法生成

待签名算法为M，为得到签名（r,s）

1. $\overline{M}=Z_A||M$

2. 计算 $e=H_v(\overline{M})$ ，将 $e$ 转换为整数
3. 随机生成 $k$ ， $k\in[1,n-1]$ 
4. 计算椭圆曲线点 $（x_1,y_1）=[k]G$ ，将 $x_1$ 转换为整数
5. 计算 $r=(e+x_1) mod n$ ,若 $r=0$ 或 $r+k=n$ ，则返回3
6. 计算 $s=((1+d_A)^{-1}\cdot(k-r\cdot d_A))mod n$ ,若 $s=0$ ，则返回3
7. 将 $r、s$ 转换为字节串，签名为 $（r,s）$

#### 签名验证算法

收到消息 $M'$ 及其数字签名 $（r',s'）$ ，验证

1. 检验 $r'\in [1,n-1]$
2. 检验 $s'\in [1,n-1]$
3. 置 $\overline{M'}=Z_A||M'$
4. 计算 $e'=H_v(\overline{M'})$ ，将 $e'$ 转换为整数
5. 将 $r',s'$ 转换为整数，计算 $t=(r'+s')mod n$ ，若 $t=0$ ，则验证不通过
6. 计算椭圆曲线点 $（x'_1,y'_1）=[s']G+[t]P_A$
7. 将 $x1'$ 转换为整数，计算 $R=(e'+x'_1)mod n$ ，检验 $R=r'$ 是否成立

#### 参数选取

$p=0x8542D69E 4C044F18 E8B92435 BF6FF7DE 45728391 5C45517D 722EDB8B 08F1DFC3$

$a=0x787968B4 FA32C3FD 2417842E 73BBFEFF 2F3C848B 6831D7E0 EC65228B 3937E498  $

$b=0x63E4C6D3 B23B0C84 9CF84241 484BFE48 F61D59A5 B16BA06E 6E12D1DA 27C5249A  $

$Gx=0x421DEBD6 1B62EAB6 746434EB C3CC315E 32220B3B ADD50BDC 4C4E6C14 7FEDD43D  $

$Gy=0x0680512B CBB42C07 D47349D2 153B70C4 E5D7FDFC BFA36EA1 A85841B9 E46E09A2 $

$n=0x8542D69E 4C044F18 E8B92435 BF6FF7DD 29772063 0485628D 5AE74EE7 C32E79B7 $

$message='hello'$

$ID_A=0x414C494345313233405941484F4F2E434F4D$

#### 实验结果

![image-20230719171922513](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230719171922513.png)


## Project12

### 项目介绍

ECDMA、Schnorr、SM2-sig存在共同的陷阱，主要陷阱如下：

* Leaking  $k$ leads to leaking of $d$

* Reusing $k$ leads to leaking of $d$

* Two users, using $k$ leads to leaking of $d$, that is they can deduce each other’s $d$

* Malleability, e.g. $(r,s)$ and $(r,-s)$ are both valid signatures, lead to blockchain network split

* Same $d$ and $k$ with ECDSA, leads to leaking of $d$

* Ambiguity of DER encode could lead to blockchain network split

* One can forge signature if the verification does not check $m$

本项目以ECDSA为例，实现了前五个陷阱攻击。

### 结果展示

![image-20230723160825408](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230723160825408.png)

## Project13

### ECMH简介

Elliptic curve MultiSet Hash (ECMH)是一种基于椭圆曲线的多集哈希算法，用于将多个元素映射到一个椭圆曲线上，并将曲线上的点作为哈希值。

ECMH算法的基本思想是，将每个元素编码成一个椭圆曲线上的点，然后将这些点相加得到一个新的点，最终将这个点的坐标作为哈希值。具体来说，ECMH算法的步骤如下：

1. 选择一个椭圆曲线和一个基点，作为哈希算法的参数。
2. 将每个元素编码成一个点，并将所有点相加得到一个新的点。
3. 将新点的X坐标作为哈希值。

ECMH算法的优点是，在保证安全性的前提下，具有较高的哈希速度和较小的哈希值长度。另外，ECMH算法还具有一些其他的特性，如支持动态更新、支持批量哈希等。

ECMH算法已经被应用到了一些密码学应用中，如区块链、数字签名等。但是，由于其相对较新的性质和相对较少的应用经验，目前还没有被广泛使用。

### 实现过程

* 依赖库及参数选取

```python
import numpy as np
import sympy
import hashlib

p=int('0x8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3',16)
a=int('0x787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498',16)
b=int('0x63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A',16) 
```

* 椭圆曲线上加法实现

```python
def calculate_p_q(x1, y1, x2, y2, a, b, p):
    flag = 1

    if x1 == x2 and y1 == y2:
        member = 3 * (x1 ** 2) + a  
        denominator = 2 * y1  

    else:
        member = y2 - y1
        denominator = x2 - x1
        if member * denominator < 0:
            flag = 0
            member = abs(member)
            denominator = abs(denominator)

    gcd_value = get_gcd(member, denominator)
    member = member // gcd_value
    denominator = denominator // gcd_value

    inverse_value = sympy.mod_inverse(denominator, p)
    k = (member * inverse_value)
    if flag == 0:
        k = -k
    k = k % p

    x3 = (k ** 2 - x1 - x2) % p
    y3 = (k * (x1 - x3) - y1) % p
    return [x3, y3]
```

* hash函数选取为sha256

```python
def sha256(data):
    hash_obj = hashlib.sha256()
    hash_obj.update(data)
    return hash_obj.digest()
```

* 多集hash

```python
def multi_hash(set):
    point_0=[0,0]
    for item in set:
        hash_result = sha256(item)
        x=int(hash_result.hex(),16)  
        tem=np.mod(x**2+a*x+b,p)
        y = sympy.ntheory.residue_ntheory.nthroot_mod(tem,2,p)
        while(y==None):
            tem=tem+1
            y = sympy.ntheory.residue_ntheory.nthroot_mod(tem,2,p)
        point=[x,y]
        calculate_p_q(point[0], point[1], point_0[0], point_0[1], a, b, p)
    return point
```

### 实验结果

![image-20230724155045612](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230724155045612.png)


## Project14

### PGP

![image-20230724182230065](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230724182230065.png)



### 实现思路

**算法选取：**

非对称加密算法：sm2

对称加密算法：AES-128-ECB

**加密过程：**

1.发送方和接收方分别生成sm2的公钥和私钥： $(pk_s,sk_s),(pk_r,sk_r)$

2.选取对称加密算法的密钥 $K$ ,用接收方的公钥 $(pk_r)$ 加密，得到 $K_{en}$

3.发送方用 $K$ 加密信息 $m$ ，得到 $m_{en}$

4.发送方用自己的私钥 $(sk_s)$ 签名 $K_{en}$，得到签名 $sign$

5,发送 $K_{en}$， $m_{en}$， $sign$

**解密过程：**

1.对 $K_{en}$ 验签

2.接收方用自己的私钥 $(pk_s)$ 解密 $K_{en}$

3.用 $K$ 解密 $m_{en}$



### 结果展示

![image-20230724183147540](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230724183147540.png)



## Project15

### 实现方式

![image-20230726152246643](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230726152246643.png)

### 实现思路

* 为实现真实网络中的SM2的两方协同签名方案，在此项目中采用python中的socket编程方法进行双方通讯

  **服务端：**

  ```python
  HOST = '127.0.0.1'
  PORT = 50007
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  s.bind((HOST, PORT)) # 绑定socket
  s.listen(1) # 开始监听客户端连接
  print('Listening on port:',PORT)
  
  conn, addr = s.accept()
  print('Connected by', addr)
  ```

  **客户端：**

  ```python
  # 服务端主机IP地址和端口号
  HOST = '127.0.0.1'
  PORT = 50007
  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
  try:
      # 连接服务器
      s.connect((HOST, PORT))
  except Exception as e:
      print('Server not found or not open')
      sys.exit()
  ```

* SM2的实现和之前项目类似

  **参数选取：**

  ```python
  p=0x8542D69E4C044F18E8B92435BF6FF7DE457283915C45517D722EDB8B08F1DFC3
  
  a=0x787968B4FA32C3FD2417842E73BBFEFF2F3C848B6831D7E0EC65228B3937E498
  
  b=0x63E4C6D3B23B0C849CF84241484BFE48F61D59A5B16BA06E6E12D1DA27C5249A
  
  xG=0x421DEBD61B62EAB6746434EBC3CC315E32220B3BADD50BDC4C4E6C147FEDD43D
  
  yG=0x0680512BCBB42C07D47349D2153B70C4E5D7FDFCBFA36EA1A85841B9E46E09A2
  
  n=0x8542D69E4C044F18E8B92435BF6FF7DD297720630485628D5AE74EE7C32E79B7
  
  mess1="hello"
  
  IDA=0x414C494345313233405941484F4F2E434F4D
  ```

  **生成P1:**

  ```python
  d1=random.randint(1,n)
  def generate_P1(d1):
      #print(d1)
      d1_inv=mod_inverse(d1,n)
      #print(d1_inv)
      P1=calculate_np(xG, yG, d1_inv, a, b, p)
      return P1
  ```

  **生成Q1,e:**

  ```python
  def generate_e_Q1(ID,mess,P1,k1):
      M = mess.encode()
      ENTL = get_bitsize(ID) * 8
      data = ENTL.to_bytes(2, byteorder='big', signed=False) + int_to_bytes(ID) + 	int_to_bytes(a) + int_to_bytes(b) + int_to_bytes(xG) + int_to_bytes(yG) + 		int_to_bytes(P1[0]) + int_to_bytes(P1[1])
      # print(data)
      ZA = sm3(data)
      M_ = ZA + M
      e = bytes_to_int(sm3(M_))
      Q1 = calculate_np(xG, yG, k1, a, b, p)
      return Q1, e
  ```

  **生成r,s2,s3:**

  ```python
  def generate_r_s2_s3(Q1,e,d2):
      k2 = random.randint(1, n)
      Q2 = calculate_np(xG, yG, k2, a, b, p)
      k3 = random.randint(1, n)
      tem = calculate_np(Q1[0], Q1[1], k3, a, b, p)
      res = calculate_p_q(tem[0], tem[1], Q2[0], Q2[1], a, b, p)
      r = (res[0] + e) % n
      s2 = (d2*k3) % n
      s3 = (d2*(r+k2)) % n
      return r, s2, s3
  ```

### 结果展示

![image-20230726153326850](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230726153326850.png)

![image-20230726153330319](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230726153330319.png)



## Project16

### 项目介绍

为实现通过真实网络进行sm2的2P解密，我们采用socket编程。其中，双方所需要的公钥等信息由utils.py文件生成。此外，其中一方所需要的密文C也由utils.py生成。

### 实验内容

![image-20230730112331180](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230730112331180.png)

### 实现流程

client端：

* 建立连接
* 计算T1并传递
* 接收T2
* 恢复明文

sever端：

* 建立连接
* 接收T1
* 计算T2并传递

### 实验结果

![image-20230730112706274](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230730112706274.png)

![image-20230730112710021](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230730112710021.png)



## Project17

本项目主要比较了两种浏览器的记住密码插件中对于账户密码的储存方式以及储存内容的区别，具体内容请见  `compare.md`  文件。

## Project17

### 项目说明

本实验实现过程中使用的主要控制台指令见解析tx.txt文件

### 实现流程

* 下载 Bitcoin Core 和 Bitcoin Core test 并等待数据同步。数据同步后打开 Bitcoin Core test ，生成比特币地址。
* 获取免费的测试网络比特币：打开`https://coinfaucet.eu/en/btc-testnet`，输入第一步中生成的比特币地址即可领取。领取后钱包中“可使用余额”不再为0。如下图所示：

![image-20230801152548836](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230801152548836.png)



* 接下来进行比特币交易，发送地址仍然填写第一步生成的地址，即自己发送给自己，并添加手续费：



![image-20230801152757711](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230801152757711.png)



* 等待交易处理完毕，我们就可以查询交易信息。

  

  ![image-20230801152953129](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230801152953129.png)

  可以看到交易ID为：`5eed6708f64a33d41625c38772a08d724607b99b41d0a6806dfd0333a7a3b4c0`

  

* 在控制台输入命令：`gettransaction 5eed6708f64a33d41625c38772a08d724607b99b41d0a6806dfd0333a7a3b4c0`

  得到以下信息：

  ```
  {
    "amount": 0.00000000,
    "fee": -0.00000141,
    "confirmations": 9,
    "blockhash": "000000000000003e67833ef4cfebae091af9b37dd86036407a6c3afbe3181913",
    "blockheight": 2470170,
    "blockindex": 15,
    "blocktime": 1690871176,
    "txid": "5eed6708f64a33d41625c38772a08d724607b99b41d0a6806dfd0333a7a3b4c0",
    "walletconflicts": [
    ],
    "time": 1690871102,
    "timereceived": 1690871102,
    "bip125-replaceable": "no",
    "details": [
      {
        "address": "tb1qdnava283hrs0jswf7l8x8353aw4wuc8cgh02w7",
        "category": "send",
        "amount": -0.00099859,
        "label": "",
        "vout": 1,
        "fee": -0.00000141,
        "abandoned": false
      },
      {
        "address": "tb1qdnava283hrs0jswf7l8x8353aw4wuc8cgh02w7",
        "category": "receive",
        "amount": 0.00099859,
        "label": "",
        "vout": 1
      }
    ],
    "hex": "02000000000101445701b2fe3ef9689853f52c2c5544db93fb939fb5f58bfa78dc3436f4cd9cda0000000000fdffffff02855a2900000000001600145058ccd3be6a668ce196cbd44917a2397e380cc913860100000000001600146cfacea8f1b8e0f941c9f7ce63c691ebaaee60f80247304402204a6d7d86cb66c5011b043d345626b18f1dd67bcc28c5281a53c8598484c8d7ad02201a9276ad8269ff4a2a94943cd0bc3975c05aaf55aabad517458793c5c9d9ef2d0121025560dc8e49e062b0aa14ffb83b4fb892c838161170adcff16bf49eeac80f5a1919b12500"
  }
  ```

  

* 最后我们对上边结果给出的原始十六进制编码数据进行解析，命令为：

```
decoderawtransaction 02000000000101445701b2fe3ef9689853f52c2c5544db93fb939fb5f58bfa78dc3436f4cd9cda0000000000fdffffff02855a2900000000001600145058ccd3be6a668ce196cbd44917a2397e380cc913860100000000001600146cfacea8f1b8e0f941c9f7ce63c691ebaaee60f80247304402204a6d7d86cb66c5011b043d345626b18f1dd67bcc28c5281a53c8598484c8d7ad02201a9276ad8269ff4a2a94943cd0bc3975c05aaf55aabad517458793c5c9d9ef2d0121025560dc8e49e062b0aa14ffb83b4fb892c838161170adcff16bf49eeac80f5a1919b12500`
```

​	最终得到以下交易结果信息：

```

15:12:43
￼
{
  "txid": "5eed6708f64a33d41625c38772a08d724607b99b41d0a6806dfd0333a7a3b4c0",
  "hash": "201a7ac72d29397fed41540afb6c36767ec6ef078fcabbca91d0c3c01b5ae88b",
  "version": 2,
  "size": 222,
  "vsize": 141,
  "weight": 561,
  "locktime": 2470169,
  "vin": [
    {
      "txid": "da9ccdf43634dc78fa8bf5b59f93fb93db44552c2cf5539868f93efeb2015744",
      "vout": 0,
      "scriptSig": {
        "asm": "",
        "hex": ""
      },
      "txinwitness": [
        "304402204a6d7d86cb66c5011b043d345626b18f1dd67bcc28c5281a53c8598484c8d7ad02201a9276ad8269ff4a2a94943cd0bc3975c05aaf55aabad517458793c5c9d9ef2d01",
        "025560dc8e49e062b0aa14ffb83b4fb892c838161170adcff16bf49eeac80f5a19"
      ],
      "sequence": 4294967293
    }
  ],
  "vout": [
    {
      "value": 0.02710149,
      "n": 0,
      "scriptPubKey": {
        "asm": "0 5058ccd3be6a668ce196cbd44917a2397e380cc9",
        "hex": "00145058ccd3be6a668ce196cbd44917a2397e380cc9",
        "address": "tb1q2pvve5a7dfngecvke02yj9az89lrsrxflt597c",
        "type": "witness_v0_keyhash"
      }
    },
    {
      "value": 0.00099859,
      "n": 1,
      "scriptPubKey": {
        "asm": "0 6cfacea8f1b8e0f941c9f7ce63c691ebaaee60f8",
        "hex": "00146cfacea8f1b8e0f941c9f7ce63c691ebaaee60f8",
        "address": "tb1qdnava283hrs0jswf7l8x8353aw4wuc8cgh02w7",
        "type": "witness_v0_keyhash"
      }
    }
  ]
}

```


## Project19

### 项目介绍

forge a signature to pretend that you are Satoshi，伪造签名冒充中本聪
ECDSA（Elliptic Curve Digital Signature Algorithm）是一种基于椭圆曲线密码学的数字签名算法。它是一种非对称加密算法，使用私钥对数据签名，并使用公钥验证签名的有效性。

ECDSA签名的过程如下：

1. 选择一个椭圆曲线和一个点作为基点。
2. 生成一个私钥，它是一个随机数。
3. 通过私钥生成公钥，它是一个点。
4. 对要签名的数据进行哈希。
5. 生成一个随机数作为临时私钥。
6. 用临时私钥计算临时公钥。
7. 计算签名，包括两个部分：r和s。其中，r是临时公钥的x坐标模曲线上的数，s是一个计算得出的值。
8. 将r和s组成签名。
9. 将签名和原始数据一起发送。

验证ECDSA签名的过程如下：

1. 对原始数据进行哈希。
2. 从签名中提取r和s。
3. 计算一个值v，它是签名中的一个公共值。
4. 用公钥和v的值计算一个点。
5. 计算一个值r'，它是该点的x坐标模曲线上的数。
6. 如果r'等于r，则签名有效，否则签名无效。

### 结果展示

<img width="168" alt="project19实验结果" src="https://github.com/OrangeFender/2023SDU-Innovation-and-Entrepreneurship/assets/138659606/8557762c-2520-4245-b518-e359a00163f4">

## Project20

此项目和project13重复，故具体内容请见project13。

## Project21

### 算法介绍

**生成签名：**

* 选择一个随机数$k$, 令 $R = kG$
* 令$ s = k + H(m || R || P)*x$
* 得到签名$(R,s)$

**验证签名：**

* $sG = R + H(m || R || P)P$

**批量验证：**

* $$ \sum_{i=1}^n s_i * G = \sum_{i=1}^n R_i + H(m || R || P)* \sum_{i=1}^nP_i$$

### 项目介绍

在本项目中，实现了对多组签名进行分别验证和对多组签名进行批量验证，分别命名为`Schnorr.py`和`Schnorr Bacth.py`。本项目中hash函数选取为`sha256`，且进行简化处理，取`H（m)`。具体实现过程请见`py`文件。

### 实验结果

![image-20230730182023870](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230730182023870.png)

![image-20230730182030995](C:\Users\lzdwy\AppData\Roaming\Typora\typora-user-images\image-20230730182030995.png)

